use std::path::PathBuf;
use std::process::Command;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=proto/");
    println!("cargo:rerun-if-changed=../../protoc-gen-synapse/");

    let src_generated = PathBuf::from("src/generated");

    // Clean and recreate generated directory
    let _ = std::fs::remove_dir_all(&src_generated);
    std::fs::create_dir_all(&src_generated)?;

    // Generate gRPC code with tonic (to OUT_DIR for include_proto!)
    tonic_build::configure()
        .build_server(true)
        .build_client(true)
        .compile_protos(
            &[
                "proto/iam/services.proto",
                "proto/blog/services.proto",
                "../../proto/synapse/relay/types.proto",
            ],
            &["proto/", "../../proto/"],
        )?;

    // Build protoc-gen-synapse in release mode
    let build_status = Command::new("cargo")
        .args([
            "build",
            "--release",
            "--manifest-path",
            "../../protoc-gen-synapse/Cargo.toml",
        ])
        .status()?;

    if !build_status.success() {
        println!("cargo:warning=Failed to build protoc-gen-synapse");
        return Ok(());
    }

    // Run protoc separately for each service to avoid duplicate file issues
    // IAM services first
    let status = Command::new("protoc")
        .args([
            "--plugin=protoc-gen-synapse=../../target/release/protoc-gen-synapse",
            &format!("--synapse_out=backend=seaorm:{}", src_generated.display()),
            "-I../../proto",
            "-Iproto",
            "proto/iam/services.proto",
        ])
        .status();

    match status {
        Ok(s) if s.success() => println!("cargo:warning=IAM code generation succeeded"),
        Ok(s) => {
            println!("cargo:warning=IAM code generation failed with: {}", s);
            return Ok(());
        }
        Err(e) => {
            println!("cargo:warning=Failed to run protoc-gen-synapse for IAM: {}", e);
            return Ok(());
        }
    }

    // Blog services second
    let status = Command::new("protoc")
        .args([
            "--plugin=protoc-gen-synapse=../../target/release/protoc-gen-synapse",
            &format!("--synapse_out=backend=seaorm:{}", src_generated.display()),
            "-I../../proto",
            "-Iproto",
            "proto/blog/services.proto",
        ])
        .status();

    match status {
        Ok(s) if s.success() => println!("cargo:warning=Blog code generation succeeded"),
        Ok(s) => println!("cargo:warning=Blog code generation failed with: {}", s),
        Err(e) => println!("cargo:warning=Failed to run protoc-gen-synapse for Blog: {}", e),
    }

    // Create the synapse module structure for relay types
    let synapse_dir = src_generated.join("synapse");
    let relay_dir = synapse_dir.join("relay");
    let relay_graphql_dir = relay_dir.join("graphql");
    std::fs::create_dir_all(&relay_graphql_dir)?;

    std::fs::write(
        synapse_dir.join("mod.rs"),
        r#"//! Synapse generated types
//! @generated
#![allow(missing_docs)]
pub mod relay;
"#,
    )?;

    std::fs::write(
        relay_dir.join("mod.rs"),
        r#"//! Relay types (PageInfo, filters, etc.)
//! @generated
#![allow(missing_docs)]
#![allow(clippy::all)]
tonic::include_proto!("synapse.relay");

pub mod graphql;
"#,
    )?;

    // Create the graphql module that re-exports all shared types
    // The actual type files are generated by protoc-gen-synapse
    std::fs::write(
        relay_graphql_dir.join("mod.rs"),
        r#"//! Shared GraphQL types (filters, PageInfo, etc.)
//! @generated
#![allow(missing_docs)]
#![allow(unused_imports)]

mod int_filter;
mod string_filter;
mod bool_filter;
mod float_filter;
mod timestamp_filter;
mod order_direction;
mod page_info;

pub use int_filter::IntFilter;
pub use string_filter::StringFilter;
pub use bool_filter::BoolFilter;
pub use float_filter::FloatFilter;
pub use timestamp_filter::TimestampFilter;
pub use order_direction::OrderDirection;
pub use page_info::PageInfo;
"#,
    )?;

    // Create root mod.rs
    std::fs::write(
        src_generated.join("mod.rs"),
        r#"//! Generated code from proto definitions
//! @generated

#![allow(missing_docs)]
#![allow(unused_imports)]
#![allow(clippy::all)]
#![allow(dead_code)]

pub mod synapse;
pub mod iam;
pub mod blog;
"#,
    )?;

    Ok(())
}
