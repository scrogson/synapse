//! Synapse Full-Stack Example
//!
//! This example demonstrates a complete application with:
//! - PostgreSQL database with SeaORM
//! - gRPC API with Tonic
//! - GraphQL API with async-graphql + axum
//!
//! All code except this main.rs is generated by protoc-gen-synapse
//! from the proto definitions.
//!
//! Run with:
//!   docker-compose up -d
//!   cargo run

use std::net::SocketAddr;
use std::sync::Arc;

use async_graphql_axum::{GraphQLRequest, GraphQLResponse};
use axum::{extract::State, routing::get, Router};
use sea_orm::Database;
use tonic::transport::Server as TonicServer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

// Include the generated code
mod generated;

use generated::blog::{
    user_service_server::UserServiceServer,
    post_service_server::PostServiceServer,
    SeaOrmUserServiceStorage,
    SeaOrmPostServiceStorage,
    UserServiceGrpcService,
    PostServiceGrpcService,
    graphql_schema::{build_schema, BlogSchema},
};

/// GraphQL handler
async fn graphql_handler(
    State(schema): State<BlogSchema>,
    req: GraphQLRequest,
) -> GraphQLResponse {
    schema.execute(req.into_inner()).await.into()
}

/// Apollo Sandbox handler (embedded)
async fn apollo_sandbox() -> impl axum::response::IntoResponse {
    axum::response::Html(r#"<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Apollo Sandbox</title>
    <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
    <div id="sandbox" style="width: 100vw; height: 100vh;"></div>
    <script src="https://embeddable-sandbox.cdn.apollographql.com/_latest/embeddable-sandbox.umd.production.min.js"></script>
    <script>
        new window.EmbeddedSandbox({
            target: '#sandbox',
            initialEndpoint: window.location.origin + '/graphql',
        });
    </script>
</body>
</html>"#)
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize tracing
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(
            std::env::var("RUST_LOG").unwrap_or_else(|_| "info".into()),
        ))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // Load environment variables
    dotenvy::dotenv().ok();

    // Connect to database
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgres://synapse:synapse@localhost:5433/synapse_blog".into());

    tracing::info!("Connecting to database...");
    let db = Database::connect(&database_url).await?;
    tracing::info!("Database connected!");

    // Create shared storage implementations
    let user_storage = Arc::new(SeaOrmUserServiceStorage::new(db.clone()));
    let post_storage = Arc::new(SeaOrmPostServiceStorage::new(db.clone()));

    // Build GraphQL schema
    let schema = build_schema(user_storage.clone(), post_storage.clone());

    // Create storage for gRPC (needs owned instances)
    let user_storage_grpc = SeaOrmUserServiceStorage::new(db.clone());
    let post_storage_grpc = SeaOrmPostServiceStorage::new(db.clone());

    // Wrap storage in gRPC services
    let user_grpc = UserServiceGrpcService::new(user_storage_grpc);
    let post_grpc = PostServiceGrpcService::new(post_storage_grpc);

    // gRPC server address
    let grpc_addr: SocketAddr = std::env::var("GRPC_ADDR")
        .unwrap_or_else(|_| "0.0.0.0:50060".into())
        .parse()?;

    // GraphQL server address
    let graphql_addr: SocketAddr = std::env::var("GRAPHQL_ADDR")
        .unwrap_or_else(|_| "0.0.0.0:8080".into())
        .parse()?;

    tracing::info!("gRPC server listening on {}", grpc_addr);
    tracing::info!("GraphQL server listening on {}", graphql_addr);
    tracing::info!("Apollo Sandbox available at http://{}/", graphql_addr);

    // Build axum router for GraphQL
    let app = Router::new()
        .route("/graphql", get(apollo_sandbox).post(graphql_handler))
        .route("/", get(apollo_sandbox))
        .with_state(schema);

    // Spawn gRPC server
    let grpc_server = TonicServer::builder()
        .add_service(UserServiceServer::new(user_grpc))
        .add_service(PostServiceServer::new(post_grpc))
        .serve(grpc_addr);

    // Spawn GraphQL server
    let graphql_server = axum::serve(
        tokio::net::TcpListener::bind(graphql_addr).await?,
        app,
    );

    // Run both servers concurrently
    tokio::select! {
        result = grpc_server => {
            if let Err(e) = result {
                tracing::error!("gRPC server error: {}", e);
            }
        }
        result = graphql_server => {
            if let Err(e) = result {
                tracing::error!("GraphQL server error: {}", e);
            }
        }
    }

    Ok(())
}
