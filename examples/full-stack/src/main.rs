//! Synapse Full-Stack Example
//!
//! This example demonstrates a complete application with:
//! - PostgreSQL database with SeaORM
//! - gRPC API with Tonic
//! - GraphQL API with async-graphql + axum
//!
//! Architecture:
//! - gRPC server uses storage directly (SeaORM)
//! - GraphQL server uses gRPC clients with DataLoaders for N+1 prevention
//!
//! All code except this main.rs is generated by protoc-gen-synapse
//! from the proto definitions.
//!
//! Run with:
//!   docker-compose up -d
//!   cargo run

use std::net::SocketAddr;
use std::time::Duration;

use async_graphql_axum::{GraphQLRequest, GraphQLResponse};
use axum::{extract::State, routing::get, Router};
use sea_orm::Database;
use tonic::transport::{Channel, Server as TonicServer};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

use synapse_full_stack_example::blog::{
    author_service_server::AuthorServiceServer,
    post_service_server::PostServiceServer,
    author_service_client::AuthorServiceClient,
    post_service_client::PostServiceClient,
    SeaOrmAuthorServiceStorage,
    SeaOrmPostServiceStorage,
    AuthorServiceGrpcService,
    PostServiceGrpcService,
    graphql::{build_schema, AppSchema},
};

/// GraphQL handler
async fn graphql_handler(
    State(schema): State<AppSchema>,
    req: GraphQLRequest,
) -> GraphQLResponse {
    schema.execute(req.into_inner()).await.into()
}

/// Apollo Sandbox handler (embedded)
async fn apollo_sandbox() -> impl axum::response::IntoResponse {
    axum::response::Html(r#"<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Apollo Sandbox</title>
    <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
    <div id="sandbox" style="width: 100vw; height: 100vh;"></div>
    <script src="https://embeddable-sandbox.cdn.apollographql.com/_latest/embeddable-sandbox.umd.production.min.js"></script>
    <script>
        new window.EmbeddedSandbox({
            target: '#sandbox',
            initialEndpoint: window.location.origin + '/graphql',
        });
    </script>
</body>
</html>"#)
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize tracing
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(
            std::env::var("RUST_LOG").unwrap_or_else(|_| "info".into()),
        ))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // Load environment variables
    dotenvy::dotenv().ok();

    // Connect to database
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgres://synapse:synapse@localhost:5433/synapse_blog".into());

    tracing::info!("Connecting to database...");
    let db = Database::connect(&database_url).await?;
    tracing::info!("Database connected!");

    // Create storage implementations for gRPC server
    let author_storage = SeaOrmAuthorServiceStorage::new(db.clone());
    let post_storage = SeaOrmPostServiceStorage::new(db.clone());

    // Wrap storage in gRPC services
    let author_grpc = AuthorServiceGrpcService::new(author_storage);
    let post_grpc = PostServiceGrpcService::new(post_storage);

    // gRPC server address
    let grpc_addr: SocketAddr = std::env::var("GRPC_ADDR")
        .unwrap_or_else(|_| "0.0.0.0:50060".into())
        .parse()?;

    // GraphQL server address
    let graphql_addr: SocketAddr = std::env::var("GRAPHQL_ADDR")
        .unwrap_or_else(|_| "0.0.0.0:8080".into())
        .parse()?;

    tracing::info!("Starting gRPC server on {}", grpc_addr);

    // Start gRPC server in background task
    let grpc_server = TonicServer::builder()
        .add_service(AuthorServiceServer::new(author_grpc))
        .add_service(PostServiceServer::new(post_grpc))
        .serve(grpc_addr);

    tokio::spawn(async move {
        if let Err(e) = grpc_server.await {
            tracing::error!("gRPC server error: {}", e);
        }
    });

    // Wait for gRPC server to be ready
    tokio::time::sleep(Duration::from_millis(100)).await;

    // Create gRPC clients for GraphQL resolvers
    let grpc_endpoint = format!("http://127.0.0.1:{}", grpc_addr.port());
    tracing::info!("Connecting GraphQL to gRPC at {}", grpc_endpoint);

    let channel = Channel::from_shared(grpc_endpoint)?
        .connect()
        .await?;

    let author_client = AuthorServiceClient::new(channel.clone());
    let post_client = PostServiceClient::new(channel);

    // Build GraphQL schema with gRPC clients (enables DataLoader batching)
    let schema = build_schema(author_client, post_client);

    tracing::info!("GraphQL server listening on {}", graphql_addr);
    tracing::info!("Apollo Sandbox available at http://{}/", graphql_addr);

    // Build axum router for GraphQL
    let app = Router::new()
        .route("/graphql", get(apollo_sandbox).post(graphql_handler))
        .route("/", get(apollo_sandbox))
        .with_state(schema);

    // Start GraphQL server
    let listener = tokio::net::TcpListener::bind(graphql_addr).await?;
    axum::serve(listener, app).await?;

    Ok(())
}
