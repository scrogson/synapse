//! GraphQL module
//!
//! Re-exports generated types and provides Query/Mutation schema.
//! All types are generated by protoc-gen-synapse.
//! @generated
#![allow(missing_docs)]
#![allow(unused_imports)]
#![allow(dead_code)]
mod user;
mod post;
mod create_user_input;
mod update_user_input;
mod create_post_input;
mod update_post_input;
mod string_filter;
mod bool_filter;
mod int64_filter;
mod user_filter;
mod user_order_by;
mod post_filter;
mod post_order_by;
mod user_service_query;
mod user_service_mutation;
mod post_service_query;
mod post_service_mutation;
pub use user::User;
pub use post::Post;
pub use create_user_input::CreateUserInput;
pub use update_user_input::UpdateUserInput;
pub use create_post_input::CreatePostInput;
pub use update_post_input::UpdatePostInput;
pub use string_filter::StringFilter;
pub use bool_filter::BoolFilter;
pub use int64_filter::Int64Filter;
pub use user_filter::UserFilter;
pub use user_order_by::UserOrderBy;
pub use post_filter::PostFilter;
pub use post_order_by::PostOrderBy;
pub use user_service_query::UserServiceQuery;
pub use post_service_query::PostServiceQuery;
pub use user_service_mutation::UserServiceMutation;
pub use post_service_mutation::PostServiceMutation;
use async_graphql::{
    Object, Context, Result, ID, EmptySubscription, Schema, MergedObject,
};
use std::sync::Arc;
use super::SeaOrmUserServiceStorage;
use super::SeaOrmPostServiceStorage;
/// Relay PageInfo
#[derive(async_graphql::SimpleObject, Clone, Default)]
pub struct PageInfo {
    pub has_next_page: bool,
    pub has_previous_page: bool,
    pub start_cursor: Option<String>,
    pub end_cursor: Option<String>,
}
impl From<super::PageInfo> for PageInfo {
    fn from(p: super::PageInfo) -> Self {
        Self {
            has_next_page: p.has_next_page,
            has_previous_page: p.has_previous_page,
            start_cursor: p.start_cursor,
            end_cursor: p.end_cursor,
        }
    }
}
/// Order direction for sorting
#[derive(async_graphql::Enum, Clone, Copy, PartialEq, Eq, Default)]
pub enum OrderDirection {
    #[default]
    /// Ascending order
    Asc,
    /// Descending order
    Desc,
}
impl From<OrderDirection> for super::OrderDirection {
    fn from(d: OrderDirection) -> Self {
        match d {
            OrderDirection::Asc => Self::Asc,
            OrderDirection::Desc => Self::Desc,
        }
    }
}
impl From<super::OrderDirection> for OrderDirection {
    fn from(d: super::OrderDirection) -> Self {
        match d {
            super::OrderDirection::Asc => Self::Asc,
            super::OrderDirection::Desc => Self::Desc,
            _ => Self::Asc,
        }
    }
}
///Relay Edge for User
#[derive(async_graphql::SimpleObject, Clone)]
pub struct UserEdge {
    pub cursor: String,
    pub node: User,
}
///Relay Connection for User
#[derive(async_graphql::SimpleObject, Clone)]
pub struct UserConnection {
    pub edges: Vec<UserEdge>,
    pub page_info: PageInfo,
}
impl From<super::UserConnection> for UserConnection {
    fn from(c: super::UserConnection) -> Self {
        Self {
            edges: c
                .edges
                .into_iter()
                .map(|edge| {
                    let node = edge
                        .node
                        .map(User::from)
                        .expect("Edge node should not be None");
                    UserEdge {
                        cursor: edge.cursor,
                        node,
                    }
                })
                .collect(),
            page_info: c.page_info.map(PageInfo::from).unwrap_or_default(),
        }
    }
}
///Relay Edge for Post
#[derive(async_graphql::SimpleObject, Clone)]
pub struct PostEdge {
    pub cursor: String,
    pub node: Post,
}
///Relay Connection for Post
#[derive(async_graphql::SimpleObject, Clone)]
pub struct PostConnection {
    pub edges: Vec<PostEdge>,
    pub page_info: PageInfo,
}
impl From<super::PostConnection> for PostConnection {
    fn from(c: super::PostConnection) -> Self {
        Self {
            edges: c
                .edges
                .into_iter()
                .map(|edge| {
                    let node = edge
                        .node
                        .map(Post::from)
                        .expect("Edge node should not be None");
                    PostEdge {
                        cursor: edge.cursor,
                        node,
                    }
                })
                .collect(),
            page_info: c.page_info.map(PageInfo::from).unwrap_or_default(),
        }
    }
}
/// Combined Query merging all service queries
#[derive(MergedObject, Default)]
pub struct Query(UserServiceQuery, PostServiceQuery);
/// Combined Mutation merging all service mutations
#[derive(MergedObject, Default)]
pub struct Mutation(UserServiceMutation, PostServiceMutation);
/// Schema type alias
pub type AppSchema = Schema<Query, Mutation, EmptySubscription>;
/// Build the GraphQL schema with storage instances
pub fn build_schema(
    user_service_storage: Arc<SeaOrmUserServiceStorage>,
    post_service_storage: Arc<SeaOrmPostServiceStorage>,
) -> AppSchema {
    Schema::build(Query::default(), Mutation::default(), EmptySubscription)
        .data(user_service_storage)
        .data(post_service_storage)
        .finish()
}
