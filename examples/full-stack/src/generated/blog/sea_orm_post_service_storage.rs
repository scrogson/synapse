//!SeaORM-based storage implementation for PostService
//!
//! Generated by protoc-gen-synapse from protobuf service definition.
//! @generated
#![allow(missing_docs)]
#![allow(unused_imports)]
use super::prelude::*;
use super::post_service_storage::{PostServiceStorage, StorageError};
use super::conversions::ApplyUpdate;
use sea_orm::{
    ActiveModelTrait, ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter,
    QueryOrder, Set,
};
///SeaORM-based implementation of PostServiceStorage using DatabaseConnection
#[derive(Clone)]
pub struct SeaOrmPostServiceStorage {
    db: DatabaseConnection,
}
impl SeaOrmPostServiceStorage {
    /// Create a new storage implementation with the given database connection
    pub fn new(db: DatabaseConnection) -> Self {
        Self { db }
    }
    /// Get a reference to the database connection
    pub fn db(&self) -> &DatabaseConnection {
        &self.db
    }
}
#[async_trait::async_trait]
impl PostServiceStorage for SeaOrmPostServiceStorage {
    async fn get_post(
        &self,
        request: GetPostRequest,
    ) -> Result<GetPostResponse, StorageError> {
        let model = post::Entity::find_by_id(request.id)
            .one(&self.db)
            .await
            .map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(
                format!("{} with id {} not found", stringify!(Post), request.id),
            ))?;
        Ok(GetPostResponse {
            post: Some(model.into()),
        })
    }
    async fn list_posts(
        &self,
        request: ListPostsRequest,
    ) -> Result<PostConnection, StorageError> {
        use sea_orm::{QuerySelect, Condition};
        let limit = request.first.or(request.last).unwrap_or(20) as u64;
        let mut query = post::Entity::find();
        if let Some(ref filter) = request.filter {
            let mut cond = Condition::all();
            if let Some(ref f) = filter.id {
                if let Some(v) = f.eq {
                    cond = cond.add(post::Column::Id.eq(v));
                }
                if let Some(v) = f.ne {
                    cond = cond.add(post::Column::Id.ne(v));
                }
                if let Some(v) = f.gt {
                    cond = cond.add(post::Column::Id.gt(v));
                }
                if let Some(v) = f.gte {
                    cond = cond.add(post::Column::Id.gte(v));
                }
                if let Some(v) = f.lt {
                    cond = cond.add(post::Column::Id.lt(v));
                }
                if let Some(v) = f.lte {
                    cond = cond.add(post::Column::Id.lte(v));
                }
                if !f.r#in.is_empty() {
                    cond = cond.add(post::Column::Id.is_in(f.r#in.clone()));
                }
            }
            if let Some(ref f) = filter.title {
                if let Some(ref v) = f.eq {
                    cond = cond.add(post::Column::Title.eq(v.clone()));
                }
                if let Some(ref v) = f.ne {
                    cond = cond.add(post::Column::Title.ne(v.clone()));
                }
                if let Some(ref v) = f.contains {
                    cond = cond.add(post::Column::Title.contains(v));
                }
                if let Some(ref v) = f.starts_with {
                    cond = cond.add(post::Column::Title.starts_with(v));
                }
                if let Some(ref v) = f.ends_with {
                    cond = cond.add(post::Column::Title.ends_with(v));
                }
            }
            if let Some(ref f) = filter.content {
                if let Some(ref v) = f.eq {
                    cond = cond.add(post::Column::Content.eq(v.clone()));
                }
                if let Some(ref v) = f.ne {
                    cond = cond.add(post::Column::Content.ne(v.clone()));
                }
                if let Some(ref v) = f.contains {
                    cond = cond.add(post::Column::Content.contains(v));
                }
                if let Some(ref v) = f.starts_with {
                    cond = cond.add(post::Column::Content.starts_with(v));
                }
                if let Some(ref v) = f.ends_with {
                    cond = cond.add(post::Column::Content.ends_with(v));
                }
            }
            if let Some(ref f) = filter.published {
                if let Some(v) = f.eq {
                    cond = cond.add(post::Column::Published.eq(v));
                }
            }
            if let Some(ref f) = filter.author_id {
                if let Some(v) = f.eq {
                    cond = cond.add(post::Column::AuthorId.eq(v));
                }
                if let Some(v) = f.ne {
                    cond = cond.add(post::Column::AuthorId.ne(v));
                }
                if let Some(v) = f.gt {
                    cond = cond.add(post::Column::AuthorId.gt(v));
                }
                if let Some(v) = f.gte {
                    cond = cond.add(post::Column::AuthorId.gte(v));
                }
                if let Some(v) = f.lt {
                    cond = cond.add(post::Column::AuthorId.lt(v));
                }
                if let Some(v) = f.lte {
                    cond = cond.add(post::Column::AuthorId.lte(v));
                }
                if !f.r#in.is_empty() {
                    cond = cond.add(post::Column::AuthorId.is_in(f.r#in.clone()));
                }
            }
            query = query.filter(cond);
        }
        let mut ordered = false;
        if let Some(ref o) = request.order_by {
            if let Some(d) = o.id {
                ordered = true;
                query = if d == 1 {
                    query.order_by_asc(post::Column::Id)
                } else {
                    query.order_by_desc(post::Column::Id)
                };
            }
            if let Some(d) = o.title {
                ordered = true;
                query = if d == 1 {
                    query.order_by_asc(post::Column::Title)
                } else {
                    query.order_by_desc(post::Column::Title)
                };
            }
            if let Some(d) = o.published {
                ordered = true;
                query = if d == 1 {
                    query.order_by_asc(post::Column::Published)
                } else {
                    query.order_by_desc(post::Column::Published)
                };
            }
            if let Some(d) = o.created_at {
                ordered = true;
                query = if d == 1 {
                    query.order_by_asc(post::Column::CreatedAt)
                } else {
                    query.order_by_desc(post::Column::CreatedAt)
                };
            }
            if let Some(d) = o.updated_at {
                ordered = true;
                query = if d == 1 {
                    query.order_by_asc(post::Column::UpdatedAt)
                } else {
                    query.order_by_desc(post::Column::UpdatedAt)
                };
            }
        }
        if !ordered {
            query = query.order_by_asc(post::Column::Id);
        }
        if let Some(ref after) = request.after {
            if let Ok(cursor_id) = after.parse::<i64>() {
                query = query.filter(post::Column::Id.gt(cursor_id));
            }
        }
        if let Some(ref before) = request.before {
            if let Ok(cursor_id) = before.parse::<i64>() {
                query = query.filter(post::Column::Id.lt(cursor_id));
            }
        }
        let models = query
            .limit(limit + 1)
            .all(&self.db)
            .await
            .map_err(StorageError::Database)?;
        let has_next_page = models.len() > limit as usize;
        let models: Vec<_> = models.into_iter().take(limit as usize).collect();
        let edges: Vec<PostEdge> = models
            .into_iter()
            .map(|m| {
                let cursor = m.id.to_string();
                PostEdge {
                    cursor,
                    node: Some(m.into()),
                }
            })
            .collect();
        let start_cursor = edges.first().map(|e| e.cursor.clone());
        let end_cursor = edges.last().map(|e| e.cursor.clone());
        Ok(PostConnection {
            edges,
            page_info: Some(PageInfo {
                has_next_page,
                has_previous_page: request.after.is_some(),
                start_cursor,
                end_cursor,
            }),
        })
    }
    async fn create_post(
        &self,
        request: CreatePostRequest,
    ) -> Result<CreatePostResponse, StorageError> {
        let input = request
            .input
            .ok_or_else(|| {
                StorageError::InvalidArgument("input is required".to_string())
            })?;
        let active_model: post::ActiveModel = input.into();
        let model = active_model.insert(&self.db).await.map_err(StorageError::Database)?;
        Ok(CreatePostResponse {
            post: Some(model.into()),
        })
    }
    async fn update_post(
        &self,
        request: UpdatePostRequest,
    ) -> Result<UpdatePostResponse, StorageError> {
        use sea_orm::IntoActiveModel;
        let input = request
            .input
            .ok_or_else(|| {
                StorageError::InvalidArgument("input is required".to_string())
            })?;
        let model = post::Entity::find_by_id(request.id)
            .one(&self.db)
            .await
            .map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(
                format!("{} with id {} not found", stringify!(Post), request.id),
            ))?;
        let mut active_model = model.into_active_model();
        active_model.apply_update(input);
        let model = active_model.update(&self.db).await.map_err(StorageError::Database)?;
        Ok(UpdatePostResponse {
            post: Some(model.into()),
        })
    }
    async fn delete_post(
        &self,
        request: DeletePostRequest,
    ) -> Result<DeletePostResponse, StorageError> {
        let result = post::Entity::delete_by_id(request.id)
            .exec(&self.db)
            .await
            .map_err(StorageError::Database)?;
        Ok(DeletePostResponse {
            success: result.rows_affected > 0,
        })
    }
}
