//!gRPC service implementation for UserService
//!
//! Generated by protoc-gen-synapse from protobuf service definition.
//! @generated
#![allow(missing_docs)]
#![allow(unused_imports)]
use super::prelude::*;
use super::user_service_storage::{UserServiceStorage, StorageError};
use tonic::{Request, Response, Status};
/// Validation error for request field failures
#[derive(Debug, thiserror::Error)]
pub enum ValidationError {
    /// A field failed validation
    #[error("Invalid field '{field}': {message}")]
    InvalidField {
        /// The field that failed validation
        field: String,
        /// Description of the validation failure
        message: String,
    },
    /// A required field was missing
    #[error("Missing required field: {0}")]
    MissingRequired(String),
}
/// Service-level error wrapping validation and storage errors
#[derive(Debug, thiserror::Error)]
pub enum ServiceError {
    /// Request validation failed
    #[error("Validation failed: {0}")]
    Validation(#[from] ValidationError),
    /// Storage operation failed
    #[error("Storage error: {0}")]
    Storage(#[from] StorageError),
}
impl From<ServiceError> for tonic::Status {
    fn from(e: ServiceError) -> Self {
        match e {
            ServiceError::Validation(v) => tonic::Status::invalid_argument(v.to_string()),
            ServiceError::Storage(s) => {
                match s {
                    StorageError::NotFound(msg) => tonic::Status::not_found(msg),
                    StorageError::Database(db_err) => {
                        tonic::Status::internal(db_err.to_string())
                    }
                    StorageError::InvalidArgument(msg) => {
                        tonic::Status::invalid_argument(msg)
                    }
                }
            }
        }
    }
}
///gRPC service wrapper for UserService that delegates to UserServiceStorage
pub struct UserServiceGrpcService<S: UserServiceStorage + 'static> {
    storage: S,
}
impl<S: UserServiceStorage + 'static> UserServiceGrpcService<S> {
    /// Create a new gRPC service with the given storage implementation
    pub fn new(storage: S) -> Self {
        Self { storage }
    }
    /// Get a reference to the underlying storage
    pub fn storage(&self) -> &S {
        &self.storage
    }
    /// Get a mutable reference to the underlying storage
    pub fn storage_mut(&mut self) -> &mut S {
        &mut self.storage
    }
    /// Consume the service and return the storage
    pub fn into_storage(self) -> S {
        self.storage
    }
}
#[tonic::async_trait]
impl<S: UserServiceStorage + 'static> user_service_server::UserService
for UserServiceGrpcService<S> {
    async fn get_user(
        &self,
        request: Request<GetUserRequest>,
    ) -> Result<Response<GetUserResponse>, Status> {
        self.storage
            .get_user(request.into_inner())
            .await
            .map(Response::new)
            .map_err(|e| tonic::Status::from(ServiceError::Storage(e)))
    }
    async fn list_users(
        &self,
        request: Request<ListUsersRequest>,
    ) -> Result<Response<UserConnection>, Status> {
        self.storage
            .list_users(request.into_inner())
            .await
            .map(Response::new)
            .map_err(|e| tonic::Status::from(ServiceError::Storage(e)))
    }
    async fn create_user(
        &self,
        request: Request<CreateUserRequest>,
    ) -> Result<Response<CreateUserResponse>, Status> {
        self.storage
            .create_user(request.into_inner())
            .await
            .map(Response::new)
            .map_err(|e| tonic::Status::from(ServiceError::Storage(e)))
    }
    async fn update_user(
        &self,
        request: Request<UpdateUserRequest>,
    ) -> Result<Response<UpdateUserResponse>, Status> {
        self.storage
            .update_user(request.into_inner())
            .await
            .map(Response::new)
            .map_err(|e| tonic::Status::from(ServiceError::Storage(e)))
    }
    async fn delete_user(
        &self,
        request: Request<DeleteUserRequest>,
    ) -> Result<Response<DeleteUserResponse>, Status> {
        self.storage
            .delete_user(request.into_inner())
            .await
            .map(Response::new)
            .map_err(|e| tonic::Status::from(ServiceError::Storage(e)))
    }
}
