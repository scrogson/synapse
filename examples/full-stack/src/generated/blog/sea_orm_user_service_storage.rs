//!SeaORM-based storage implementation for UserService
//! This file is manually generated by build.rs to add filter/orderBy support.
#![allow(missing_docs)]
#![allow(unused_imports)]
use super::prelude::*;
use super::user_service_storage::{UserServiceStorage, StorageError};
use super::conversions::ApplyUpdate;
use sea_orm::{
    ActiveModelTrait, ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter,
    QueryOrder, Set, Condition,
};

#[derive(Clone)]
pub struct SeaOrmUserServiceStorage {
    db: DatabaseConnection,
}

impl SeaOrmUserServiceStorage {
    pub fn new(db: DatabaseConnection) -> Self {
        Self { db }
    }
    pub fn db(&self) -> &DatabaseConnection {
        &self.db
    }
}

#[async_trait::async_trait]
impl UserServiceStorage for SeaOrmUserServiceStorage {
    async fn get_user(&self, request: GetUserRequest) -> Result<GetUserResponse, StorageError> {
        let model = user::Entity::find_by_id(request.id)
            .one(&self.db).await.map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(format!("User {} not found", request.id)))?;
        Ok(GetUserResponse { user: Some(model.into()) })
    }

    async fn list_users(&self, request: ListUsersRequest) -> Result<UserConnection, StorageError> {
        use sea_orm::QuerySelect;
        let limit = request.first.or(request.last).unwrap_or(20) as u64;
        let mut query = user::Entity::find();

        // Apply filters
        if let Some(ref filter) = request.filter {
            let mut cond = Condition::all();
            if let Some(ref f) = filter.id {
                if let Some(v) = f.eq { cond = cond.add(user::Column::Id.eq(v)); }
                if let Some(v) = f.ne { cond = cond.add(user::Column::Id.ne(v)); }
                if let Some(v) = f.gt { cond = cond.add(user::Column::Id.gt(v)); }
                if let Some(v) = f.gte { cond = cond.add(user::Column::Id.gte(v)); }
                if let Some(v) = f.lt { cond = cond.add(user::Column::Id.lt(v)); }
                if let Some(v) = f.lte { cond = cond.add(user::Column::Id.lte(v)); }
                if !f.r#in.is_empty() { cond = cond.add(user::Column::Id.is_in(f.r#in.clone())); }
            }
            if let Some(ref f) = filter.email {
                if let Some(ref v) = f.eq { cond = cond.add(user::Column::Email.eq(v.clone())); }
                if let Some(ref v) = f.contains { cond = cond.add(user::Column::Email.contains(v)); }
                if let Some(ref v) = f.starts_with { cond = cond.add(user::Column::Email.starts_with(v)); }
            }
            if let Some(ref f) = filter.name {
                if let Some(ref v) = f.eq { cond = cond.add(user::Column::Name.eq(v.clone())); }
                if let Some(ref v) = f.contains { cond = cond.add(user::Column::Name.contains(v)); }
            }
            query = query.filter(cond);
        }

        // Apply ordering
        let mut ordered = false;
        if let Some(ref o) = request.order_by {
            if let Some(d) = o.id { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::Id) } else { query.order_by_desc(user::Column::Id) }; }
            if let Some(d) = o.email { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::Email) } else { query.order_by_desc(user::Column::Email) }; }
            if let Some(d) = o.name { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::Name) } else { query.order_by_desc(user::Column::Name) }; }
            if let Some(d) = o.created_at { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::CreatedAt) } else { query.order_by_desc(user::Column::CreatedAt) }; }
            if let Some(d) = o.updated_at { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::UpdatedAt) } else { query.order_by_desc(user::Column::UpdatedAt) }; }
        }
        if !ordered { query = query.order_by_asc(user::Column::Id); }

        // Cursor pagination
        if let Some(ref after) = request.after {
            if let Ok(id) = after.parse::<i64>() { query = query.filter(user::Column::Id.gt(id)); }
        }
        if let Some(ref before) = request.before {
            if let Ok(id) = before.parse::<i64>() { query = query.filter(user::Column::Id.lt(id)); }
        }

        let models = query.limit(limit + 1).all(&self.db).await.map_err(StorageError::Database)?;
        let has_next = models.len() > limit as usize;
        let models: Vec<_> = models.into_iter().take(limit as usize).collect();
        let edges: Vec<UserEdge> = models.into_iter().map(|m| UserEdge { cursor: m.id.to_string(), node: Some(m.into()) }).collect();
        let start = edges.first().map(|e| e.cursor.clone());
        let end = edges.last().map(|e| e.cursor.clone());
        Ok(UserConnection { edges, page_info: Some(PageInfo { has_next_page: has_next, has_previous_page: request.after.is_some(), start_cursor: start, end_cursor: end }) })
    }

    async fn create_user(&self, request: CreateUserRequest) -> Result<CreateUserResponse, StorageError> {
        let input = request.input.ok_or_else(|| StorageError::InvalidArgument("input required".into()))?;
        let active_model: user::ActiveModel = input.into();
        let model = active_model.insert(&self.db).await.map_err(StorageError::Database)?;
        Ok(CreateUserResponse { user: Some(model.into()) })
    }

    async fn update_user(&self, request: UpdateUserRequest) -> Result<UpdateUserResponse, StorageError> {
        use sea_orm::IntoActiveModel;
        let input = request.input.ok_or_else(|| StorageError::InvalidArgument("input required".into()))?;
        let model = user::Entity::find_by_id(request.id).one(&self.db).await.map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(format!("User {} not found", request.id)))?;
        let mut am = model.into_active_model();
        am.apply_update(input);
        let model = am.update(&self.db).await.map_err(StorageError::Database)?;
        Ok(UpdateUserResponse { user: Some(model.into()) })
    }

    async fn delete_user(&self, request: DeleteUserRequest) -> Result<DeleteUserResponse, StorageError> {
        let result = user::Entity::delete_by_id(request.id).exec(&self.db).await.map_err(StorageError::Database)?;
        Ok(DeleteUserResponse { success: result.rows_affected > 0 })
    }
}
