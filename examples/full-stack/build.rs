use std::path::PathBuf;
use std::process::Command;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=proto/");
    println!("cargo:rerun-if-changed=../../protoc-gen-synapse/");

    let src_generated = PathBuf::from("src/generated");
    std::fs::create_dir_all(&src_generated)?;

    // Generate gRPC code with tonic (to OUT_DIR for include_proto!)
    tonic_build::configure()
        .build_server(true)
        .build_client(true)
        .compile_protos(
            &["proto/blog.proto"],
            &["proto/", "../../proto/"],
        )?;

    // Generate Synapse code (SeaORM entities, storage traits, implementations)
    // First, build protoc-gen-synapse in release mode
    let build_status = Command::new("cargo")
        .args([
            "build",
            "--release",
            "--manifest-path",
            "../../protoc-gen-synapse/Cargo.toml",
        ])
        .status()?;

    if !build_status.success() {
        println!("cargo:warning=Failed to build protoc-gen-synapse");
        return Ok(());
    }

    // Run protoc with our plugin (to src/generated for direct imports)
    let status = Command::new("protoc")
        .args([
            "--plugin=protoc-gen-synapse=../../protoc-gen-synapse/target/release/protoc-gen-synapse",
            &format!("--synapse_out=backend=seaorm:{}", src_generated.display()),
            "-I../../proto",
            "-Iproto",
            "proto/blog.proto",
        ])
        .status();

    match status {
        Ok(s) if s.success() => println!("cargo:warning=Synapse code generation succeeded"),
        Ok(s) => println!("cargo:warning=Synapse code generation failed with: {}", s),
        Err(e) => println!("cargo:warning=Failed to run protoc-gen-synapse: {}", e),
    }

    // Create a mod.rs file that includes all generated modules
    let mod_content = r#"//! Generated code from proto definitions
//!
//! This module is auto-generated by build.rs

#![allow(missing_docs)]
#![allow(unused_imports)]
#![allow(clippy::all)]
#![allow(dead_code)]

// Synapse-generated code is in the blog/ subdirectory
pub mod blog;
"#;

    std::fs::write(src_generated.join("mod.rs"), mod_content)?;

    // Create a blog/mod.rs that combines tonic and synapse generated code
    let blog_dir = src_generated.join("blog");
    std::fs::create_dir_all(&blog_dir)?;

    let blog_mod_content = r#"//! Blog module - combines tonic and synapse generated code
//!
//! This module is auto-generated by build.rs

#![allow(missing_docs)]
#![allow(unused_imports)]
#![allow(clippy::all)]
#![allow(dead_code)]

// Include tonic-generated gRPC code (from OUT_DIR)
tonic::include_proto!("blog");

// Prelude for synapse-generated code
pub mod prelude {
    pub use sea_orm::entity::prelude::*;
    pub use sea_orm::{DatabaseConnection, DbErr};

    // Re-export proto types from parent
    pub use super::*;

    // Storage error type
    #[derive(Debug, thiserror::Error)]
    pub enum StorageError {
        #[error("database error: {0}")]
        Database(#[from] sea_orm::DbErr),
        #[error("not found: {0}")]
        NotFound(String),
        #[error("invalid argument: {0}")]
        InvalidArgument(String),
    }
}

// Include synapse-generated entities
pub mod user;
pub mod post;

// Include synapse-generated storage traits
pub mod user_service_storage;
pub mod post_service_storage;

// Include synapse-generated storage implementations
pub mod sea_orm_user_service_storage;
pub mod sea_orm_post_service_storage;

// Include synapse-generated gRPC services
pub mod user_service;
pub mod post_service;

// Conversions between proto types and SeaORM entities
pub mod conversions;

// GraphQL schema
pub mod graphql_schema;

// Re-export for convenience
pub use user::Model as UserModel;
pub use post::Model as PostModel;
pub use user_service_storage::UserServiceStorage;
pub use post_service_storage::PostServiceStorage;
pub use sea_orm_user_service_storage::SeaOrmUserServiceStorage;
pub use sea_orm_post_service_storage::SeaOrmPostServiceStorage;
pub use user_service::UserServiceGrpcService;
pub use post_service::PostServiceGrpcService;
"#;

    std::fs::write(blog_dir.join("mod.rs"), blog_mod_content)?;

    // Create conversions.rs with From implementations
    let conversions_content = r#"//! Conversions between proto types and SeaORM entities
//!
//! This module is auto-generated by build.rs

#![allow(missing_docs)]
#![allow(unused_imports)]

use super::prelude::*;
use super::{user, post};
use sea_orm::ActiveValue::Set;

// ============================================================================
// User conversions
// ============================================================================

/// Convert SeaORM User Model to proto User
impl From<user::Model> for User {
    fn from(model: user::Model) -> Self {
        Self {
            id: model.id,
            email: model.email,
            name: model.name,
            bio: model.bio,
            created_at: Some(prost_types::Timestamp {
                seconds: model.created_at.timestamp(),
                nanos: model.created_at.timestamp_subsec_nanos() as i32,
            }),
            updated_at: Some(prost_types::Timestamp {
                seconds: model.updated_at.timestamp(),
                nanos: model.updated_at.timestamp_subsec_nanos() as i32,
            }),
        }
    }
}

/// Convert CreateUserInput to SeaORM ActiveModel
impl From<CreateUserInput> for user::ActiveModel {
    fn from(input: CreateUserInput) -> Self {
        Self {
            email: Set(input.email),
            name: Set(input.name),
            bio: Set(input.bio),
            ..Default::default()
        }
    }
}

/// Extension trait for applying updates to an active model
pub trait ApplyUpdate<T> {
    fn apply_update(&mut self, input: T);
}

/// Apply UpdateUserInput to User ActiveModel
impl ApplyUpdate<UpdateUserInput> for user::ActiveModel {
    fn apply_update(&mut self, input: UpdateUserInput) {
        if let Some(email) = input.email {
            self.email = Set(email);
        }
        if let Some(name) = input.name {
            self.name = Set(name);
        }
        if let Some(bio) = input.bio {
            self.bio = Set(Some(bio));
        }
    }
}

// ============================================================================
// Post conversions
// ============================================================================

/// Convert SeaORM Post Model to proto Post
impl From<post::Model> for Post {
    fn from(model: post::Model) -> Self {
        Self {
            id: model.id,
            title: model.title,
            content: model.content,
            published: model.published,
            author_id: model.author_id,
            created_at: Some(prost_types::Timestamp {
                seconds: model.created_at.timestamp(),
                nanos: model.created_at.timestamp_subsec_nanos() as i32,
            }),
            updated_at: Some(prost_types::Timestamp {
                seconds: model.updated_at.timestamp(),
                nanos: model.updated_at.timestamp_subsec_nanos() as i32,
            }),
        }
    }
}

/// Convert CreatePostInput to SeaORM ActiveModel
impl From<CreatePostInput> for post::ActiveModel {
    fn from(input: CreatePostInput) -> Self {
        Self {
            title: Set(input.title),
            content: Set(input.content),
            published: Set(input.published),
            author_id: Set(input.author_id),
            ..Default::default()
        }
    }
}

/// Apply UpdatePostInput to Post ActiveModel
impl ApplyUpdate<UpdatePostInput> for post::ActiveModel {
    fn apply_update(&mut self, input: UpdatePostInput) {
        if let Some(title) = input.title {
            self.title = Set(title);
        }
        if let Some(content) = input.content {
            self.content = Set(content);
        }
        if let Some(published) = input.published {
            self.published = Set(published);
        }
    }
}
"#;

    std::fs::write(blog_dir.join("conversions.rs"), conversions_content)?;

    // Create graphql_schema.rs
    let graphql_schema_content = r#"//! GraphQL schema using async-graphql
//!
//! This module provides Query and Mutation types that use the storage layer.

#![allow(missing_docs)]
#![allow(unused_imports)]

use async_graphql::{Object, Context, Result, ID, InputObject, SimpleObject, EmptySubscription, Schema};
use super::user_service_storage::{UserServiceStorage, StorageError as UserStorageError};
use super::post_service_storage::{PostServiceStorage, StorageError as PostStorageError};
use super::sea_orm_user_service_storage::SeaOrmUserServiceStorage;
use super::sea_orm_post_service_storage::SeaOrmPostServiceStorage;
use std::sync::Arc;

// Import proto types with an alias to avoid conflicts
use super::{
    User as ProtoUser,
    Post as ProtoPost,
    GetUserRequest, GetUserResponse,
    ListUsersRequest, UserConnection as ProtoUserConnection, UserEdge as ProtoUserEdge,
    CreateUserRequest, CreateUserInput as ProtoCreateUserInput, CreateUserResponse,
    UpdateUserRequest, UpdateUserInput as ProtoUpdateUserInput, UpdateUserResponse,
    DeleteUserRequest, DeleteUserResponse,
    GetPostRequest, GetPostResponse,
    ListPostsRequest, PostConnection as ProtoPostConnection, PostEdge as ProtoPostEdge,
    CreatePostRequest, CreatePostInput as ProtoCreatePostInput, CreatePostResponse,
    UpdatePostRequest, UpdatePostInput as ProtoUpdatePostInput, UpdatePostResponse,
    DeletePostRequest, DeletePostResponse,
    PageInfo as ProtoPageInfo,
};

// ============================================================================
// GraphQL Types
// ============================================================================

/// User type
#[derive(SimpleObject, Clone)]
pub struct User {
    pub id: ID,
    pub email: String,
    pub name: String,
    pub bio: Option<String>,
    pub created_at: String,
    pub updated_at: String,
}

impl From<ProtoUser> for User {
    fn from(u: ProtoUser) -> Self {
        Self {
            id: ID(u.id.to_string()),
            email: u.email,
            name: u.name,
            bio: u.bio,
            created_at: u.created_at.map(|t| {
                chrono::DateTime::from_timestamp(t.seconds, t.nanos as u32)
                    .map(|dt| dt.to_rfc3339())
                    .unwrap_or_default()
            }).unwrap_or_default(),
            updated_at: u.updated_at.map(|t| {
                chrono::DateTime::from_timestamp(t.seconds, t.nanos as u32)
                    .map(|dt| dt.to_rfc3339())
                    .unwrap_or_default()
            }).unwrap_or_default(),
        }
    }
}

/// Post type
#[derive(SimpleObject, Clone)]
pub struct Post {
    pub id: ID,
    pub title: String,
    pub content: String,
    pub published: bool,
    pub author_id: ID,
    pub created_at: String,
    pub updated_at: String,
}

impl From<ProtoPost> for Post {
    fn from(p: ProtoPost) -> Self {
        Self {
            id: ID(p.id.to_string()),
            title: p.title,
            content: p.content,
            published: p.published,
            author_id: ID(p.author_id.to_string()),
            created_at: p.created_at.map(|t| {
                chrono::DateTime::from_timestamp(t.seconds, t.nanos as u32)
                    .map(|dt| dt.to_rfc3339())
                    .unwrap_or_default()
            }).unwrap_or_default(),
            updated_at: p.updated_at.map(|t| {
                chrono::DateTime::from_timestamp(t.seconds, t.nanos as u32)
                    .map(|dt| dt.to_rfc3339())
                    .unwrap_or_default()
            }).unwrap_or_default(),
        }
    }
}

/// Relay PageInfo
#[derive(SimpleObject, Clone)]
pub struct PageInfo {
    pub has_next_page: bool,
    pub has_previous_page: bool,
    pub start_cursor: Option<String>,
    pub end_cursor: Option<String>,
}

/// Relay UserEdge
#[derive(SimpleObject, Clone)]
pub struct UserEdge {
    pub cursor: String,
    pub node: User,
}

/// Relay UserConnection
#[derive(SimpleObject, Clone)]
pub struct UserConnection {
    pub edges: Vec<UserEdge>,
    pub page_info: PageInfo,
}

/// Relay PostEdge
#[derive(SimpleObject, Clone)]
pub struct PostEdge {
    pub cursor: String,
    pub node: Post,
}

/// Relay PostConnection
#[derive(SimpleObject, Clone)]
pub struct PostConnection {
    pub edges: Vec<PostEdge>,
    pub page_info: PageInfo,
}

// ============================================================================
// Input Types
// ============================================================================

#[derive(InputObject)]
pub struct CreateUserInput {
    pub email: String,
    pub name: String,
    pub bio: Option<String>,
}

#[derive(InputObject)]
pub struct UpdateUserInput {
    pub email: Option<String>,
    pub name: Option<String>,
    pub bio: Option<String>,
}

#[derive(InputObject)]
pub struct CreatePostInput {
    pub title: String,
    pub content: String,
    pub published: bool,
    pub author_id: i64,
}

#[derive(InputObject)]
pub struct UpdatePostInput {
    pub title: Option<String>,
    pub content: Option<String>,
    pub published: Option<bool>,
}

// ============================================================================
// Query
// ============================================================================

pub struct Query;

#[Object]
impl Query {
    /// Get a user by ID
    async fn user(&self, ctx: &Context<'_>, id: i64) -> Result<Option<User>> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmUserServiceStorage>>();
        let request = GetUserRequest { id };
        match storage.get_user(request).await {
            Ok(response) => Ok(response.user.map(User::from)),
            Err(UserStorageError::NotFound(_)) => Ok(None),
            Err(e) => Err(async_graphql::Error::new(e.to_string())),
        }
    }

    /// List users with Relay-style pagination
    async fn users(
        &self,
        ctx: &Context<'_>,
        after: Option<String>,
        before: Option<String>,
        first: Option<i32>,
        last: Option<i32>,
    ) -> Result<UserConnection> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmUserServiceStorage>>();
        let request = ListUsersRequest { after, before, first, last };
        let response = storage.list_users(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;

        let page_info = response.page_info.map(|p| PageInfo {
            has_next_page: p.has_next_page,
            has_previous_page: p.has_previous_page,
            start_cursor: p.start_cursor,
            end_cursor: p.end_cursor,
        }).unwrap_or(PageInfo {
            has_next_page: false,
            has_previous_page: false,
            start_cursor: None,
            end_cursor: None,
        });

        let edges = response.edges.into_iter().map(|e| {
            UserEdge {
                cursor: e.cursor,
                node: e.node.map(User::from).unwrap_or_else(|| User {
                    id: ID::from(""),
                    email: String::new(),
                    name: String::new(),
                    bio: None,
                    created_at: String::new(),
                    updated_at: String::new(),
                }),
            }
        }).collect();

        Ok(UserConnection { edges, page_info })
    }

    /// Get a post by ID
    async fn post(&self, ctx: &Context<'_>, id: i64) -> Result<Option<Post>> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmPostServiceStorage>>();
        let request = GetPostRequest { id };
        match storage.get_post(request).await {
            Ok(response) => Ok(response.post.map(Post::from)),
            Err(PostStorageError::NotFound(_)) => Ok(None),
            Err(e) => Err(async_graphql::Error::new(e.to_string())),
        }
    }

    /// List posts with Relay-style pagination
    async fn posts(
        &self,
        ctx: &Context<'_>,
        after: Option<String>,
        before: Option<String>,
        first: Option<i32>,
        last: Option<i32>,
    ) -> Result<PostConnection> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmPostServiceStorage>>();
        let request = ListPostsRequest { after, before, first, last };
        let response = storage.list_posts(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;

        let page_info = response.page_info.map(|p| PageInfo {
            has_next_page: p.has_next_page,
            has_previous_page: p.has_previous_page,
            start_cursor: p.start_cursor,
            end_cursor: p.end_cursor,
        }).unwrap_or(PageInfo {
            has_next_page: false,
            has_previous_page: false,
            start_cursor: None,
            end_cursor: None,
        });

        let edges = response.edges.into_iter().map(|e| {
            PostEdge {
                cursor: e.cursor,
                node: e.node.map(Post::from).unwrap_or_else(|| Post {
                    id: ID::from(""),
                    title: String::new(),
                    content: String::new(),
                    published: false,
                    author_id: ID::from(""),
                    created_at: String::new(),
                    updated_at: String::new(),
                }),
            }
        }).collect();

        Ok(PostConnection { edges, page_info })
    }
}

// ============================================================================
// Mutation
// ============================================================================

pub struct Mutation;

#[Object]
impl Mutation {
    /// Create a new user
    async fn create_user(&self, ctx: &Context<'_>, input: CreateUserInput) -> Result<User> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmUserServiceStorage>>();
        let request = CreateUserRequest {
            input: Some(ProtoCreateUserInput {
                email: input.email,
                name: input.name,
                bio: input.bio,
            }),
        };
        let response = storage.create_user(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;
        Ok(response.user.map(User::from).ok_or("Failed to create user")?)
    }

    /// Update an existing user
    async fn update_user(&self, ctx: &Context<'_>, id: i64, input: UpdateUserInput) -> Result<User> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmUserServiceStorage>>();
        let request = UpdateUserRequest {
            id,
            input: Some(ProtoUpdateUserInput {
                email: input.email,
                name: input.name,
                bio: input.bio,
            }),
        };
        let response = storage.update_user(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;
        Ok(response.user.map(User::from).ok_or("Failed to update user")?)
    }

    /// Delete a user
    async fn delete_user(&self, ctx: &Context<'_>, id: i64) -> Result<bool> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmUserServiceStorage>>();
        let request = DeleteUserRequest { id };
        let response = storage.delete_user(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;
        Ok(response.success)
    }

    /// Create a new post
    async fn create_post(&self, ctx: &Context<'_>, input: CreatePostInput) -> Result<Post> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmPostServiceStorage>>();
        let request = CreatePostRequest {
            input: Some(ProtoCreatePostInput {
                title: input.title,
                content: input.content,
                published: input.published,
                author_id: input.author_id,
            }),
        };
        let response = storage.create_post(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;
        Ok(response.post.map(Post::from).ok_or("Failed to create post")?)
    }

    /// Update an existing post
    async fn update_post(&self, ctx: &Context<'_>, id: i64, input: UpdatePostInput) -> Result<Post> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmPostServiceStorage>>();
        let request = UpdatePostRequest {
            id,
            input: Some(ProtoUpdatePostInput {
                title: input.title,
                content: input.content,
                published: input.published,
            }),
        };
        let response = storage.update_post(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;
        Ok(response.post.map(Post::from).ok_or("Failed to update post")?)
    }

    /// Delete a post
    async fn delete_post(&self, ctx: &Context<'_>, id: i64) -> Result<bool> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmPostServiceStorage>>();
        let request = DeletePostRequest { id };
        let response = storage.delete_post(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;
        Ok(response.success)
    }
}

// ============================================================================
// Schema Builder
// ============================================================================

pub type BlogSchema = Schema<Query, Mutation, EmptySubscription>;

pub fn build_schema(
    user_storage: Arc<SeaOrmUserServiceStorage>,
    post_storage: Arc<SeaOrmPostServiceStorage>,
) -> BlogSchema {
    Schema::build(Query, Mutation, EmptySubscription)
        .data(user_storage)
        .data(post_storage)
        .finish()
}
"#;

    std::fs::write(blog_dir.join("graphql_schema.rs"), graphql_schema_content)?;

    Ok(())
}
