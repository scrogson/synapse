use std::path::PathBuf;
use std::process::Command;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=proto/");
    println!("cargo:rerun-if-changed=../../protoc-gen-synapse/");

    let src_generated = PathBuf::from("src/generated");
    std::fs::create_dir_all(&src_generated)?;

    // Generate gRPC code with tonic (to OUT_DIR for include_proto!)
    tonic_build::configure()
        .build_server(true)
        .build_client(true)
        .compile_protos(
            &["proto/blog.proto"],
            &["proto/", "../../proto/"],
        )?;

    // Generate Synapse code (SeaORM entities, storage traits, implementations)
    // First, build protoc-gen-synapse in release mode
    let build_status = Command::new("cargo")
        .args([
            "build",
            "--release",
            "--manifest-path",
            "../../protoc-gen-synapse/Cargo.toml",
        ])
        .status()?;

    if !build_status.success() {
        println!("cargo:warning=Failed to build protoc-gen-synapse");
        return Ok(());
    }

    // Run protoc with our plugin (to src/generated for direct imports)
    let status = Command::new("protoc")
        .args([
            "--plugin=protoc-gen-synapse=../../protoc-gen-synapse/target/release/protoc-gen-synapse",
            &format!("--synapse_out=backend=seaorm:{}", src_generated.display()),
            "-I../../proto",
            "-Iproto",
            "proto/blog.proto",
        ])
        .status();

    match status {
        Ok(s) if s.success() => println!("cargo:warning=Synapse code generation succeeded"),
        Ok(s) => println!("cargo:warning=Synapse code generation failed with: {}", s),
        Err(e) => println!("cargo:warning=Failed to run protoc-gen-synapse: {}", e),
    }

    // Create a mod.rs file that includes all generated modules
    let mod_content = r#"//! Generated code from proto definitions
//!
//! This module is auto-generated by build.rs

#![allow(missing_docs)]
#![allow(unused_imports)]
#![allow(clippy::all)]
#![allow(dead_code)]

// Synapse-generated code is in the blog/ subdirectory
pub mod blog;
"#;

    std::fs::write(src_generated.join("mod.rs"), mod_content)?;

    // Create a blog/mod.rs that combines tonic and synapse generated code
    let blog_dir = src_generated.join("blog");
    std::fs::create_dir_all(&blog_dir)?;

    let blog_mod_content = r#"//! Blog module - combines tonic and synapse generated code
//!
//! This module is auto-generated by build.rs

#![allow(missing_docs)]
#![allow(unused_imports)]
#![allow(clippy::all)]
#![allow(dead_code)]

// Include tonic-generated gRPC code (from OUT_DIR)
tonic::include_proto!("blog");

// Prelude for synapse-generated code
pub mod prelude {
    pub use sea_orm::entity::prelude::*;
    pub use sea_orm::{DatabaseConnection, DbErr};

    // Re-export proto types from parent
    pub use super::*;

    // Storage error type
    #[derive(Debug, thiserror::Error)]
    pub enum StorageError {
        #[error("database error: {0}")]
        Database(#[from] sea_orm::DbErr),
        #[error("not found: {0}")]
        NotFound(String),
        #[error("invalid argument: {0}")]
        InvalidArgument(String),
    }
}

// Include synapse-generated entities
pub mod user;
pub mod post;

// Include synapse-generated storage traits
pub mod user_service_storage;
pub mod post_service_storage;

// Include synapse-generated storage implementations
pub mod sea_orm_user_service_storage;
pub mod sea_orm_post_service_storage;

// Include synapse-generated gRPC services
pub mod user_service;
pub mod post_service;

// Conversions between proto types and SeaORM entities
pub mod conversions;

// GraphQL schema
pub mod graphql_schema;

// Re-export for convenience
pub use user::Model as UserModel;
pub use post::Model as PostModel;
pub use user_service_storage::UserServiceStorage;
pub use post_service_storage::PostServiceStorage;
pub use sea_orm_user_service_storage::SeaOrmUserServiceStorage;
pub use sea_orm_post_service_storage::SeaOrmPostServiceStorage;
pub use user_service::UserServiceGrpcService;
pub use post_service::PostServiceGrpcService;
"#;

    std::fs::write(blog_dir.join("mod.rs"), blog_mod_content)?;

    // Create conversions.rs with From implementations
    let conversions_content = r#"//! Conversions between proto types and SeaORM entities
//!
//! This module is auto-generated by build.rs

#![allow(missing_docs)]
#![allow(unused_imports)]

use super::prelude::*;
use super::{user, post};
use sea_orm::ActiveValue::Set;

// ============================================================================
// User conversions
// ============================================================================

/// Convert SeaORM User Model to proto User
impl From<user::Model> for User {
    fn from(model: user::Model) -> Self {
        Self {
            id: model.id,
            email: model.email,
            name: model.name,
            bio: model.bio,
            created_at: Some(prost_types::Timestamp {
                seconds: model.created_at.timestamp(),
                nanos: model.created_at.timestamp_subsec_nanos() as i32,
            }),
            updated_at: Some(prost_types::Timestamp {
                seconds: model.updated_at.timestamp(),
                nanos: model.updated_at.timestamp_subsec_nanos() as i32,
            }),
        }
    }
}

/// Convert CreateUserInput to SeaORM ActiveModel
impl From<CreateUserInput> for user::ActiveModel {
    fn from(input: CreateUserInput) -> Self {
        Self {
            email: Set(input.email),
            name: Set(input.name),
            bio: Set(input.bio),
            ..Default::default()
        }
    }
}

/// Extension trait for applying updates to an active model
pub trait ApplyUpdate<T> {
    fn apply_update(&mut self, input: T);
}

/// Apply UpdateUserInput to User ActiveModel
impl ApplyUpdate<UpdateUserInput> for user::ActiveModel {
    fn apply_update(&mut self, input: UpdateUserInput) {
        if let Some(email) = input.email {
            self.email = Set(email);
        }
        if let Some(name) = input.name {
            self.name = Set(name);
        }
        if let Some(bio) = input.bio {
            self.bio = Set(Some(bio));
        }
    }
}

// ============================================================================
// Post conversions
// ============================================================================

/// Convert SeaORM Post Model to proto Post
impl From<post::Model> for Post {
    fn from(model: post::Model) -> Self {
        Self {
            id: model.id,
            title: model.title,
            content: model.content,
            published: model.published,
            author_id: model.author_id,
            created_at: Some(prost_types::Timestamp {
                seconds: model.created_at.timestamp(),
                nanos: model.created_at.timestamp_subsec_nanos() as i32,
            }),
            updated_at: Some(prost_types::Timestamp {
                seconds: model.updated_at.timestamp(),
                nanos: model.updated_at.timestamp_subsec_nanos() as i32,
            }),
        }
    }
}

/// Convert CreatePostInput to SeaORM ActiveModel
impl From<CreatePostInput> for post::ActiveModel {
    fn from(input: CreatePostInput) -> Self {
        Self {
            title: Set(input.title),
            content: Set(input.content),
            published: Set(input.published),
            author_id: Set(input.author_id),
            ..Default::default()
        }
    }
}

/// Apply UpdatePostInput to Post ActiveModel
impl ApplyUpdate<UpdatePostInput> for post::ActiveModel {
    fn apply_update(&mut self, input: UpdatePostInput) {
        if let Some(title) = input.title {
            self.title = Set(title);
        }
        if let Some(content) = input.content {
            self.content = Set(content);
        }
        if let Some(published) = input.published {
            self.published = Set(published);
        }
    }
}
"#;

    std::fs::write(blog_dir.join("conversions.rs"), conversions_content)?;

    // Create graphql_schema.rs
    let graphql_schema_content = r#"//! GraphQL schema using async-graphql
//!
//! This module provides Query and Mutation types that use the storage layer.

#![allow(missing_docs)]
#![allow(unused_imports)]

use async_graphql::{Object, Context, Result, ID, InputObject, SimpleObject, EmptySubscription, Schema, Enum};
use super::user_service_storage::{UserServiceStorage, StorageError as UserStorageError};
use super::post_service_storage::{PostServiceStorage, StorageError as PostStorageError};
use super::sea_orm_user_service_storage::SeaOrmUserServiceStorage;
use super::sea_orm_post_service_storage::SeaOrmPostServiceStorage;
use std::sync::Arc;

// Import proto types with an alias to avoid conflicts
use super::{
    User as ProtoUser,
    Post as ProtoPost,
    GetUserRequest, GetUserResponse,
    ListUsersRequest, UserConnection as ProtoUserConnection, UserEdge as ProtoUserEdge,
    CreateUserRequest, CreateUserInput as ProtoCreateUserInput, CreateUserResponse,
    UpdateUserRequest, UpdateUserInput as ProtoUpdateUserInput, UpdateUserResponse,
    DeleteUserRequest, DeleteUserResponse,
    GetPostRequest, GetPostResponse,
    ListPostsRequest, PostConnection as ProtoPostConnection, PostEdge as ProtoPostEdge,
    CreatePostRequest, CreatePostInput as ProtoCreatePostInput, CreatePostResponse,
    UpdatePostRequest, UpdatePostInput as ProtoUpdatePostInput, UpdatePostResponse,
    DeletePostRequest, DeletePostResponse,
    PageInfo as ProtoPageInfo,
    // Filter types
    StringFilter as ProtoStringFilter,
    BoolFilter as ProtoBoolFilter,
    Int64Filter as ProtoInt64Filter,
    UserFilter as ProtoUserFilter,
    PostFilter as ProtoPostFilter,
    UserOrderBy as ProtoUserOrderBy,
    PostOrderBy as ProtoPostOrderBy,
    OrderDirection as ProtoOrderDirection,
};

// ============================================================================
// GraphQL Types
// ============================================================================

/// User type
#[derive(SimpleObject, Clone)]
pub struct User {
    pub id: ID,
    pub email: String,
    pub name: String,
    pub bio: Option<String>,
    pub created_at: String,
    pub updated_at: String,
}

impl From<ProtoUser> for User {
    fn from(u: ProtoUser) -> Self {
        Self {
            id: ID(u.id.to_string()),
            email: u.email,
            name: u.name,
            bio: u.bio,
            created_at: u.created_at.map(|t| {
                chrono::DateTime::from_timestamp(t.seconds, t.nanos as u32)
                    .map(|dt| dt.to_rfc3339())
                    .unwrap_or_default()
            }).unwrap_or_default(),
            updated_at: u.updated_at.map(|t| {
                chrono::DateTime::from_timestamp(t.seconds, t.nanos as u32)
                    .map(|dt| dt.to_rfc3339())
                    .unwrap_or_default()
            }).unwrap_or_default(),
        }
    }
}

/// Post type
#[derive(SimpleObject, Clone)]
pub struct Post {
    pub id: ID,
    pub title: String,
    pub content: String,
    pub published: bool,
    pub author_id: ID,
    pub created_at: String,
    pub updated_at: String,
}

impl From<ProtoPost> for Post {
    fn from(p: ProtoPost) -> Self {
        Self {
            id: ID(p.id.to_string()),
            title: p.title,
            content: p.content,
            published: p.published,
            author_id: ID(p.author_id.to_string()),
            created_at: p.created_at.map(|t| {
                chrono::DateTime::from_timestamp(t.seconds, t.nanos as u32)
                    .map(|dt| dt.to_rfc3339())
                    .unwrap_or_default()
            }).unwrap_or_default(),
            updated_at: p.updated_at.map(|t| {
                chrono::DateTime::from_timestamp(t.seconds, t.nanos as u32)
                    .map(|dt| dt.to_rfc3339())
                    .unwrap_or_default()
            }).unwrap_or_default(),
        }
    }
}

/// Relay PageInfo
#[derive(SimpleObject, Clone)]
pub struct PageInfo {
    pub has_next_page: bool,
    pub has_previous_page: bool,
    pub start_cursor: Option<String>,
    pub end_cursor: Option<String>,
}

/// Relay UserEdge
#[derive(SimpleObject, Clone)]
pub struct UserEdge {
    pub cursor: String,
    pub node: User,
}

/// Relay UserConnection
#[derive(SimpleObject, Clone)]
pub struct UserConnection {
    pub edges: Vec<UserEdge>,
    pub page_info: PageInfo,
}

/// Relay PostEdge
#[derive(SimpleObject, Clone)]
pub struct PostEdge {
    pub cursor: String,
    pub node: Post,
}

/// Relay PostConnection
#[derive(SimpleObject, Clone)]
pub struct PostConnection {
    pub edges: Vec<PostEdge>,
    pub page_info: PageInfo,
}

// ============================================================================
// Filter & OrderBy Types
// ============================================================================

/// Sort direction
#[derive(Enum, Copy, Clone, Eq, PartialEq, Default)]
pub enum OrderDirection {
    #[default]
    ASC,
    DESC,
}

impl From<OrderDirection> for ProtoOrderDirection {
    fn from(dir: OrderDirection) -> Self {
        match dir {
            OrderDirection::ASC => ProtoOrderDirection::Asc,
            OrderDirection::DESC => ProtoOrderDirection::Desc,
        }
    }
}

/// String comparison filter
#[derive(InputObject, Default)]
pub struct StringFilter {
    pub eq: Option<String>,
    pub ne: Option<String>,
    pub contains: Option<String>,
    pub starts_with: Option<String>,
    pub ends_with: Option<String>,
}

impl From<StringFilter> for ProtoStringFilter {
    fn from(f: StringFilter) -> Self {
        Self {
            eq: f.eq,
            ne: f.ne,
            contains: f.contains,
            starts_with: f.starts_with,
            ends_with: f.ends_with,
        }
    }
}

/// Boolean comparison filter
#[derive(InputObject, Default)]
pub struct BoolFilter {
    pub eq: Option<bool>,
}

impl From<BoolFilter> for ProtoBoolFilter {
    fn from(f: BoolFilter) -> Self {
        Self { eq: f.eq }
    }
}

/// Int64 comparison filter
#[derive(InputObject, Default)]
pub struct Int64Filter {
    pub eq: Option<i64>,
    pub ne: Option<i64>,
    pub gt: Option<i64>,
    pub gte: Option<i64>,
    pub lt: Option<i64>,
    pub lte: Option<i64>,
    #[graphql(name = "in")]
    pub in_: Option<Vec<i64>>,
}

impl From<Int64Filter> for ProtoInt64Filter {
    fn from(f: Int64Filter) -> Self {
        Self {
            eq: f.eq,
            ne: f.ne,
            gt: f.gt,
            gte: f.gte,
            lt: f.lt,
            lte: f.lte,
            r#in: f.in_.unwrap_or_default(),
        }
    }
}

/// User filter
#[derive(InputObject, Default)]
pub struct UserFilter {
    pub id: Option<Int64Filter>,
    pub email: Option<StringFilter>,
    pub name: Option<StringFilter>,
    pub bio: Option<StringFilter>,
}

impl From<UserFilter> for ProtoUserFilter {
    fn from(f: UserFilter) -> Self {
        Self {
            id: f.id.map(Into::into),
            email: f.email.map(Into::into),
            name: f.name.map(Into::into),
            bio: f.bio.map(Into::into),
        }
    }
}

/// User order by
#[derive(InputObject, Default)]
pub struct UserOrderBy {
    pub id: Option<OrderDirection>,
    pub email: Option<OrderDirection>,
    pub name: Option<OrderDirection>,
    pub created_at: Option<OrderDirection>,
    pub updated_at: Option<OrderDirection>,
}

impl From<UserOrderBy> for ProtoUserOrderBy {
    fn from(o: UserOrderBy) -> Self {
        Self {
            id: o.id.map(|d| d.into()).map(|d: ProtoOrderDirection| d as i32),
            email: o.email.map(|d| d.into()).map(|d: ProtoOrderDirection| d as i32),
            name: o.name.map(|d| d.into()).map(|d: ProtoOrderDirection| d as i32),
            created_at: o.created_at.map(|d| d.into()).map(|d: ProtoOrderDirection| d as i32),
            updated_at: o.updated_at.map(|d| d.into()).map(|d: ProtoOrderDirection| d as i32),
        }
    }
}

/// Post filter
#[derive(InputObject, Default)]
pub struct PostFilter {
    pub id: Option<Int64Filter>,
    pub title: Option<StringFilter>,
    pub content: Option<StringFilter>,
    pub published: Option<BoolFilter>,
    pub author_id: Option<Int64Filter>,
}

impl From<PostFilter> for ProtoPostFilter {
    fn from(f: PostFilter) -> Self {
        Self {
            id: f.id.map(Into::into),
            title: f.title.map(Into::into),
            content: f.content.map(Into::into),
            published: f.published.map(Into::into),
            author_id: f.author_id.map(Into::into),
        }
    }
}

/// Post order by
#[derive(InputObject, Default)]
pub struct PostOrderBy {
    pub id: Option<OrderDirection>,
    pub title: Option<OrderDirection>,
    pub published: Option<OrderDirection>,
    pub created_at: Option<OrderDirection>,
    pub updated_at: Option<OrderDirection>,
}

impl From<PostOrderBy> for ProtoPostOrderBy {
    fn from(o: PostOrderBy) -> Self {
        Self {
            id: o.id.map(|d| d.into()).map(|d: ProtoOrderDirection| d as i32),
            title: o.title.map(|d| d.into()).map(|d: ProtoOrderDirection| d as i32),
            published: o.published.map(|d| d.into()).map(|d: ProtoOrderDirection| d as i32),
            created_at: o.created_at.map(|d| d.into()).map(|d: ProtoOrderDirection| d as i32),
            updated_at: o.updated_at.map(|d| d.into()).map(|d: ProtoOrderDirection| d as i32),
        }
    }
}

// ============================================================================
// Input Types
// ============================================================================

#[derive(InputObject)]
pub struct CreateUserInput {
    pub email: String,
    pub name: String,
    pub bio: Option<String>,
}

#[derive(InputObject)]
pub struct UpdateUserInput {
    pub email: Option<String>,
    pub name: Option<String>,
    pub bio: Option<String>,
}

#[derive(InputObject)]
pub struct CreatePostInput {
    pub title: String,
    pub content: String,
    pub published: bool,
    pub author_id: i64,
}

#[derive(InputObject)]
pub struct UpdatePostInput {
    pub title: Option<String>,
    pub content: Option<String>,
    pub published: Option<bool>,
}

// ============================================================================
// Query
// ============================================================================

pub struct Query;

#[Object]
impl Query {
    /// Get a user by ID
    async fn user(&self, ctx: &Context<'_>, id: i64) -> Result<Option<User>> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmUserServiceStorage>>();
        let request = GetUserRequest { id };
        match storage.get_user(request).await {
            Ok(response) => Ok(response.user.map(User::from)),
            Err(UserStorageError::NotFound(_)) => Ok(None),
            Err(e) => Err(async_graphql::Error::new(e.to_string())),
        }
    }

    /// List users with Relay-style pagination, filtering, and ordering
    async fn users(
        &self,
        ctx: &Context<'_>,
        after: Option<String>,
        before: Option<String>,
        first: Option<i32>,
        last: Option<i32>,
        filter: Option<UserFilter>,
        order_by: Option<UserOrderBy>,
    ) -> Result<UserConnection> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmUserServiceStorage>>();
        let request = ListUsersRequest {
            after,
            before,
            first,
            last,
            filter: filter.map(Into::into),
            order_by: order_by.map(Into::into),
        };
        let response = storage.list_users(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;

        let page_info = response.page_info.map(|p| PageInfo {
            has_next_page: p.has_next_page,
            has_previous_page: p.has_previous_page,
            start_cursor: p.start_cursor,
            end_cursor: p.end_cursor,
        }).unwrap_or(PageInfo {
            has_next_page: false,
            has_previous_page: false,
            start_cursor: None,
            end_cursor: None,
        });

        let edges = response.edges.into_iter().map(|e| {
            UserEdge {
                cursor: e.cursor,
                node: e.node.map(User::from).unwrap_or_else(|| User {
                    id: ID::from(""),
                    email: String::new(),
                    name: String::new(),
                    bio: None,
                    created_at: String::new(),
                    updated_at: String::new(),
                }),
            }
        }).collect();

        Ok(UserConnection { edges, page_info })
    }

    /// Get a post by ID
    async fn post(&self, ctx: &Context<'_>, id: i64) -> Result<Option<Post>> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmPostServiceStorage>>();
        let request = GetPostRequest { id };
        match storage.get_post(request).await {
            Ok(response) => Ok(response.post.map(Post::from)),
            Err(PostStorageError::NotFound(_)) => Ok(None),
            Err(e) => Err(async_graphql::Error::new(e.to_string())),
        }
    }

    /// List posts with Relay-style pagination, filtering, and ordering
    async fn posts(
        &self,
        ctx: &Context<'_>,
        after: Option<String>,
        before: Option<String>,
        first: Option<i32>,
        last: Option<i32>,
        filter: Option<PostFilter>,
        order_by: Option<PostOrderBy>,
    ) -> Result<PostConnection> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmPostServiceStorage>>();
        let request = ListPostsRequest {
            after,
            before,
            first,
            last,
            filter: filter.map(Into::into),
            order_by: order_by.map(Into::into),
        };
        let response = storage.list_posts(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;

        let page_info = response.page_info.map(|p| PageInfo {
            has_next_page: p.has_next_page,
            has_previous_page: p.has_previous_page,
            start_cursor: p.start_cursor,
            end_cursor: p.end_cursor,
        }).unwrap_or(PageInfo {
            has_next_page: false,
            has_previous_page: false,
            start_cursor: None,
            end_cursor: None,
        });

        let edges = response.edges.into_iter().map(|e| {
            PostEdge {
                cursor: e.cursor,
                node: e.node.map(Post::from).unwrap_or_else(|| Post {
                    id: ID::from(""),
                    title: String::new(),
                    content: String::new(),
                    published: false,
                    author_id: ID::from(""),
                    created_at: String::new(),
                    updated_at: String::new(),
                }),
            }
        }).collect();

        Ok(PostConnection { edges, page_info })
    }
}

// ============================================================================
// Mutation
// ============================================================================

pub struct Mutation;

#[Object]
impl Mutation {
    /// Create a new user
    async fn create_user(&self, ctx: &Context<'_>, input: CreateUserInput) -> Result<User> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmUserServiceStorage>>();
        let request = CreateUserRequest {
            input: Some(ProtoCreateUserInput {
                email: input.email,
                name: input.name,
                bio: input.bio,
            }),
        };
        let response = storage.create_user(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;
        Ok(response.user.map(User::from).ok_or("Failed to create user")?)
    }

    /// Update an existing user
    async fn update_user(&self, ctx: &Context<'_>, id: i64, input: UpdateUserInput) -> Result<User> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmUserServiceStorage>>();
        let request = UpdateUserRequest {
            id,
            input: Some(ProtoUpdateUserInput {
                email: input.email,
                name: input.name,
                bio: input.bio,
            }),
        };
        let response = storage.update_user(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;
        Ok(response.user.map(User::from).ok_or("Failed to update user")?)
    }

    /// Delete a user
    async fn delete_user(&self, ctx: &Context<'_>, id: i64) -> Result<bool> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmUserServiceStorage>>();
        let request = DeleteUserRequest { id };
        let response = storage.delete_user(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;
        Ok(response.success)
    }

    /// Create a new post
    async fn create_post(&self, ctx: &Context<'_>, input: CreatePostInput) -> Result<Post> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmPostServiceStorage>>();
        let request = CreatePostRequest {
            input: Some(ProtoCreatePostInput {
                title: input.title,
                content: input.content,
                published: input.published,
                author_id: input.author_id,
            }),
        };
        let response = storage.create_post(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;
        Ok(response.post.map(Post::from).ok_or("Failed to create post")?)
    }

    /// Update an existing post
    async fn update_post(&self, ctx: &Context<'_>, id: i64, input: UpdatePostInput) -> Result<Post> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmPostServiceStorage>>();
        let request = UpdatePostRequest {
            id,
            input: Some(ProtoUpdatePostInput {
                title: input.title,
                content: input.content,
                published: input.published,
            }),
        };
        let response = storage.update_post(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;
        Ok(response.post.map(Post::from).ok_or("Failed to update post")?)
    }

    /// Delete a post
    async fn delete_post(&self, ctx: &Context<'_>, id: i64) -> Result<bool> {
        let storage = ctx.data_unchecked::<Arc<SeaOrmPostServiceStorage>>();
        let request = DeletePostRequest { id };
        let response = storage.delete_post(request).await
            .map_err(|e| async_graphql::Error::new(e.to_string()))?;
        Ok(response.success)
    }
}

// ============================================================================
// Schema Builder
// ============================================================================

pub type BlogSchema = Schema<Query, Mutation, EmptySubscription>;

pub fn build_schema(
    user_storage: Arc<SeaOrmUserServiceStorage>,
    post_storage: Arc<SeaOrmPostServiceStorage>,
) -> BlogSchema {
    Schema::build(Query, Mutation, EmptySubscription)
        .data(user_storage)
        .data(post_storage)
        .finish()
}
"#;

    std::fs::write(blog_dir.join("graphql_schema.rs"), graphql_schema_content)?;

    // Override the generated storage implementations with filter/orderBy support
    let user_storage_impl = r#"//!SeaORM-based storage implementation for UserService
//! This file is manually generated by build.rs to add filter/orderBy support.
#![allow(missing_docs)]
#![allow(unused_imports)]
use super::prelude::*;
use super::user_service_storage::{UserServiceStorage, StorageError};
use super::conversions::ApplyUpdate;
use sea_orm::{
    ActiveModelTrait, ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter,
    QueryOrder, Set, Condition,
};

#[derive(Clone)]
pub struct SeaOrmUserServiceStorage {
    db: DatabaseConnection,
}

impl SeaOrmUserServiceStorage {
    pub fn new(db: DatabaseConnection) -> Self {
        Self { db }
    }
    pub fn db(&self) -> &DatabaseConnection {
        &self.db
    }
}

#[async_trait::async_trait]
impl UserServiceStorage for SeaOrmUserServiceStorage {
    async fn get_user(&self, request: GetUserRequest) -> Result<GetUserResponse, StorageError> {
        let model = user::Entity::find_by_id(request.id)
            .one(&self.db).await.map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(format!("User {} not found", request.id)))?;
        Ok(GetUserResponse { user: Some(model.into()) })
    }

    async fn list_users(&self, request: ListUsersRequest) -> Result<UserConnection, StorageError> {
        use sea_orm::QuerySelect;
        let limit = request.first.or(request.last).unwrap_or(20) as u64;
        let mut query = user::Entity::find();

        // Apply filters
        if let Some(ref filter) = request.filter {
            let mut cond = Condition::all();
            if let Some(ref f) = filter.id {
                if let Some(v) = f.eq { cond = cond.add(user::Column::Id.eq(v)); }
                if let Some(v) = f.ne { cond = cond.add(user::Column::Id.ne(v)); }
                if let Some(v) = f.gt { cond = cond.add(user::Column::Id.gt(v)); }
                if let Some(v) = f.gte { cond = cond.add(user::Column::Id.gte(v)); }
                if let Some(v) = f.lt { cond = cond.add(user::Column::Id.lt(v)); }
                if let Some(v) = f.lte { cond = cond.add(user::Column::Id.lte(v)); }
                if !f.r#in.is_empty() { cond = cond.add(user::Column::Id.is_in(f.r#in.clone())); }
            }
            if let Some(ref f) = filter.email {
                if let Some(ref v) = f.eq { cond = cond.add(user::Column::Email.eq(v.clone())); }
                if let Some(ref v) = f.contains { cond = cond.add(user::Column::Email.contains(v)); }
                if let Some(ref v) = f.starts_with { cond = cond.add(user::Column::Email.starts_with(v)); }
            }
            if let Some(ref f) = filter.name {
                if let Some(ref v) = f.eq { cond = cond.add(user::Column::Name.eq(v.clone())); }
                if let Some(ref v) = f.contains { cond = cond.add(user::Column::Name.contains(v)); }
            }
            query = query.filter(cond);
        }

        // Apply ordering
        let mut ordered = false;
        if let Some(ref o) = request.order_by {
            if let Some(d) = o.id { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::Id) } else { query.order_by_desc(user::Column::Id) }; }
            if let Some(d) = o.email { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::Email) } else { query.order_by_desc(user::Column::Email) }; }
            if let Some(d) = o.name { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::Name) } else { query.order_by_desc(user::Column::Name) }; }
            if let Some(d) = o.created_at { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::CreatedAt) } else { query.order_by_desc(user::Column::CreatedAt) }; }
            if let Some(d) = o.updated_at { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::UpdatedAt) } else { query.order_by_desc(user::Column::UpdatedAt) }; }
        }
        if !ordered { query = query.order_by_asc(user::Column::Id); }

        // Cursor pagination
        if let Some(ref after) = request.after {
            if let Ok(id) = after.parse::<i64>() { query = query.filter(user::Column::Id.gt(id)); }
        }
        if let Some(ref before) = request.before {
            if let Ok(id) = before.parse::<i64>() { query = query.filter(user::Column::Id.lt(id)); }
        }

        let models = query.limit(limit + 1).all(&self.db).await.map_err(StorageError::Database)?;
        let has_next = models.len() > limit as usize;
        let models: Vec<_> = models.into_iter().take(limit as usize).collect();
        let edges: Vec<UserEdge> = models.into_iter().map(|m| UserEdge { cursor: m.id.to_string(), node: Some(m.into()) }).collect();
        let start = edges.first().map(|e| e.cursor.clone());
        let end = edges.last().map(|e| e.cursor.clone());
        Ok(UserConnection { edges, page_info: Some(PageInfo { has_next_page: has_next, has_previous_page: request.after.is_some(), start_cursor: start, end_cursor: end }) })
    }

    async fn create_user(&self, request: CreateUserRequest) -> Result<CreateUserResponse, StorageError> {
        let input = request.input.ok_or_else(|| StorageError::InvalidArgument("input required".into()))?;
        let active_model: user::ActiveModel = input.into();
        let model = active_model.insert(&self.db).await.map_err(StorageError::Database)?;
        Ok(CreateUserResponse { user: Some(model.into()) })
    }

    async fn update_user(&self, request: UpdateUserRequest) -> Result<UpdateUserResponse, StorageError> {
        use sea_orm::IntoActiveModel;
        let input = request.input.ok_or_else(|| StorageError::InvalidArgument("input required".into()))?;
        let model = user::Entity::find_by_id(request.id).one(&self.db).await.map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(format!("User {} not found", request.id)))?;
        let mut am = model.into_active_model();
        am.apply_update(input);
        let model = am.update(&self.db).await.map_err(StorageError::Database)?;
        Ok(UpdateUserResponse { user: Some(model.into()) })
    }

    async fn delete_user(&self, request: DeleteUserRequest) -> Result<DeleteUserResponse, StorageError> {
        let result = user::Entity::delete_by_id(request.id).exec(&self.db).await.map_err(StorageError::Database)?;
        Ok(DeleteUserResponse { success: result.rows_affected > 0 })
    }
}
"#;

    let post_storage_impl = r#"//!SeaORM-based storage implementation for PostService
//! This file is manually generated by build.rs to add filter/orderBy support.
#![allow(missing_docs)]
#![allow(unused_imports)]
use super::prelude::*;
use super::post_service_storage::{PostServiceStorage, StorageError};
use super::conversions::ApplyUpdate;
use sea_orm::{
    ActiveModelTrait, ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter,
    QueryOrder, Set, Condition,
};

#[derive(Clone)]
pub struct SeaOrmPostServiceStorage {
    db: DatabaseConnection,
}

impl SeaOrmPostServiceStorage {
    pub fn new(db: DatabaseConnection) -> Self {
        Self { db }
    }
    pub fn db(&self) -> &DatabaseConnection {
        &self.db
    }
}

#[async_trait::async_trait]
impl PostServiceStorage for SeaOrmPostServiceStorage {
    async fn get_post(&self, request: GetPostRequest) -> Result<GetPostResponse, StorageError> {
        let model = post::Entity::find_by_id(request.id)
            .one(&self.db).await.map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(format!("Post {} not found", request.id)))?;
        Ok(GetPostResponse { post: Some(model.into()) })
    }

    async fn list_posts(&self, request: ListPostsRequest) -> Result<PostConnection, StorageError> {
        use sea_orm::QuerySelect;
        let limit = request.first.or(request.last).unwrap_or(20) as u64;
        let mut query = post::Entity::find();

        // Apply filters
        if let Some(ref filter) = request.filter {
            let mut cond = Condition::all();
            if let Some(ref f) = filter.id {
                if let Some(v) = f.eq { cond = cond.add(post::Column::Id.eq(v)); }
                if let Some(v) = f.ne { cond = cond.add(post::Column::Id.ne(v)); }
                if let Some(v) = f.gt { cond = cond.add(post::Column::Id.gt(v)); }
                if !f.r#in.is_empty() { cond = cond.add(post::Column::Id.is_in(f.r#in.clone())); }
            }
            if let Some(ref f) = filter.title {
                if let Some(ref v) = f.eq { cond = cond.add(post::Column::Title.eq(v.clone())); }
                if let Some(ref v) = f.contains { cond = cond.add(post::Column::Title.contains(v)); }
            }
            if let Some(ref f) = filter.content {
                if let Some(ref v) = f.contains { cond = cond.add(post::Column::Content.contains(v)); }
            }
            if let Some(ref f) = filter.published {
                if let Some(v) = f.eq { cond = cond.add(post::Column::Published.eq(v)); }
            }
            if let Some(ref f) = filter.author_id {
                if let Some(v) = f.eq { cond = cond.add(post::Column::AuthorId.eq(v)); }
                if !f.r#in.is_empty() { cond = cond.add(post::Column::AuthorId.is_in(f.r#in.clone())); }
            }
            query = query.filter(cond);
        }

        // Apply ordering
        let mut ordered = false;
        if let Some(ref o) = request.order_by {
            if let Some(d) = o.id { ordered = true; query = if d == 1 { query.order_by_asc(post::Column::Id) } else { query.order_by_desc(post::Column::Id) }; }
            if let Some(d) = o.title { ordered = true; query = if d == 1 { query.order_by_asc(post::Column::Title) } else { query.order_by_desc(post::Column::Title) }; }
            if let Some(d) = o.published { ordered = true; query = if d == 1 { query.order_by_asc(post::Column::Published) } else { query.order_by_desc(post::Column::Published) }; }
            if let Some(d) = o.created_at { ordered = true; query = if d == 1 { query.order_by_asc(post::Column::CreatedAt) } else { query.order_by_desc(post::Column::CreatedAt) }; }
            if let Some(d) = o.updated_at { ordered = true; query = if d == 1 { query.order_by_asc(post::Column::UpdatedAt) } else { query.order_by_desc(post::Column::UpdatedAt) }; }
        }
        if !ordered { query = query.order_by_asc(post::Column::Id); }

        // Cursor pagination
        if let Some(ref after) = request.after {
            if let Ok(id) = after.parse::<i64>() { query = query.filter(post::Column::Id.gt(id)); }
        }
        if let Some(ref before) = request.before {
            if let Ok(id) = before.parse::<i64>() { query = query.filter(post::Column::Id.lt(id)); }
        }

        let models = query.limit(limit + 1).all(&self.db).await.map_err(StorageError::Database)?;
        let has_next = models.len() > limit as usize;
        let models: Vec<_> = models.into_iter().take(limit as usize).collect();
        let edges: Vec<PostEdge> = models.into_iter().map(|m| PostEdge { cursor: m.id.to_string(), node: Some(m.into()) }).collect();
        let start = edges.first().map(|e| e.cursor.clone());
        let end = edges.last().map(|e| e.cursor.clone());
        Ok(PostConnection { edges, page_info: Some(PageInfo { has_next_page: has_next, has_previous_page: request.after.is_some(), start_cursor: start, end_cursor: end }) })
    }

    async fn create_post(&self, request: CreatePostRequest) -> Result<CreatePostResponse, StorageError> {
        let input = request.input.ok_or_else(|| StorageError::InvalidArgument("input required".into()))?;
        let active_model: post::ActiveModel = input.into();
        let model = active_model.insert(&self.db).await.map_err(StorageError::Database)?;
        Ok(CreatePostResponse { post: Some(model.into()) })
    }

    async fn update_post(&self, request: UpdatePostRequest) -> Result<UpdatePostResponse, StorageError> {
        use sea_orm::IntoActiveModel;
        let input = request.input.ok_or_else(|| StorageError::InvalidArgument("input required".into()))?;
        let model = post::Entity::find_by_id(request.id).one(&self.db).await.map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(format!("Post {} not found", request.id)))?;
        let mut am = model.into_active_model();
        am.apply_update(input);
        let model = am.update(&self.db).await.map_err(StorageError::Database)?;
        Ok(UpdatePostResponse { post: Some(model.into()) })
    }

    async fn delete_post(&self, request: DeletePostRequest) -> Result<DeletePostResponse, StorageError> {
        let result = post::Entity::delete_by_id(request.id).exec(&self.db).await.map_err(StorageError::Database)?;
        Ok(DeletePostResponse { success: result.rows_affected > 0 })
    }
}
"#;

    // Write storage implementations (overwrites protoc-gen-synapse output)
    std::fs::write(blog_dir.join("sea_orm_user_service_storage.rs"), user_storage_impl)?;
    std::fs::write(blog_dir.join("sea_orm_post_service_storage.rs"), post_storage_impl)?;

    Ok(())
}
