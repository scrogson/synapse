use std::path::PathBuf;
use std::process::Command;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=proto/");
    println!("cargo:rerun-if-changed=../../protoc-gen-synapse/");

    let src_generated = PathBuf::from("src/generated");
    std::fs::create_dir_all(&src_generated)?;

    // Generate gRPC code with tonic (to OUT_DIR for include_proto!)
    tonic_build::configure()
        .build_server(true)
        .build_client(true)
        .compile_protos(
            &["proto/blog.proto"],
            &["proto/", "../../proto/"],
        )?;

    // Generate Synapse code (SeaORM entities, storage traits, implementations)
    // First, build protoc-gen-synapse in release mode
    let build_status = Command::new("cargo")
        .args([
            "build",
            "--release",
            "--manifest-path",
            "../../protoc-gen-synapse/Cargo.toml",
        ])
        .status()?;

    if !build_status.success() {
        println!("cargo:warning=Failed to build protoc-gen-synapse");
        return Ok(());
    }

    // Run protoc with our plugin (to src/generated for direct imports)
    let status = Command::new("protoc")
        .args([
            "--plugin=protoc-gen-synapse=../../protoc-gen-synapse/target/release/protoc-gen-synapse",
            &format!("--synapse_out=backend=seaorm:{}", src_generated.display()),
            "-I../../proto",
            "-Iproto",
            "proto/blog.proto",
        ])
        .status();

    match status {
        Ok(s) if s.success() => println!("cargo:warning=Synapse code generation succeeded"),
        Ok(s) => println!("cargo:warning=Synapse code generation failed with: {}", s),
        Err(e) => println!("cargo:warning=Failed to run protoc-gen-synapse: {}", e),
    }

    // Create a mod.rs file that includes all generated modules
    let mod_content = r#"//! Generated code from proto definitions
//!
//! This module is auto-generated by build.rs

#![allow(missing_docs)]
#![allow(unused_imports)]
#![allow(clippy::all)]
#![allow(dead_code)]

// Synapse-generated code is in the blog/ subdirectory
pub mod blog;
"#;

    std::fs::write(src_generated.join("mod.rs"), mod_content)?;

    // Create a blog/mod.rs that combines tonic and synapse generated code
    let blog_dir = src_generated.join("blog");
    std::fs::create_dir_all(&blog_dir)?;

    let blog_mod_content = r#"//! Blog module - combines tonic and synapse generated code
//!
//! This module is auto-generated by build.rs

#![allow(missing_docs)]
#![allow(unused_imports)]
#![allow(clippy::all)]
#![allow(dead_code)]

// Include tonic-generated gRPC code (from OUT_DIR)
tonic::include_proto!("blog");

// Prelude for synapse-generated code
pub mod prelude {
    pub use sea_orm::entity::prelude::*;
    pub use sea_orm::{DatabaseConnection, DbErr};

    // Re-export proto types from parent
    pub use super::*;

    // Storage error type
    #[derive(Debug, thiserror::Error)]
    pub enum StorageError {
        #[error("database error: {0}")]
        Database(#[from] sea_orm::DbErr),
        #[error("not found: {0}")]
        NotFound(String),
        #[error("invalid argument: {0}")]
        InvalidArgument(String),
    }
}

// Include synapse-generated entities
pub mod user;
pub mod post;

// Include synapse-generated storage traits
pub mod user_service_storage;
pub mod post_service_storage;

// Include synapse-generated storage implementations
pub mod sea_orm_user_service_storage;
pub mod sea_orm_post_service_storage;

// Include synapse-generated gRPC services
pub mod user_service;
pub mod post_service;

// Conversions between proto types and SeaORM entities
pub mod conversions;

// GraphQL schema (synapse-generated)
pub mod graphql;

// Re-export for convenience
pub use user::Model as UserModel;
pub use post::Model as PostModel;
pub use user_service_storage::UserServiceStorage;
pub use post_service_storage::PostServiceStorage;
pub use sea_orm_user_service_storage::SeaOrmUserServiceStorage;
pub use sea_orm_post_service_storage::SeaOrmPostServiceStorage;
pub use user_service::UserServiceGrpcService;
pub use post_service::PostServiceGrpcService;
"#;

    std::fs::write(blog_dir.join("mod.rs"), blog_mod_content)?;

    // Create conversions.rs with From implementations
    let conversions_content = r#"//! Conversions between proto types and SeaORM entities
//!
//! This module is auto-generated by build.rs

#![allow(missing_docs)]
#![allow(unused_imports)]

use super::prelude::*;
use super::{user, post};
use sea_orm::ActiveValue::Set;

// ============================================================================
// User conversions
// ============================================================================

/// Convert SeaORM User Model to proto User
impl From<user::Model> for User {
    fn from(model: user::Model) -> Self {
        Self {
            id: model.id,
            email: model.email,
            name: model.name,
            bio: model.bio,
            created_at: Some(prost_types::Timestamp {
                seconds: model.created_at.timestamp(),
                nanos: model.created_at.timestamp_subsec_nanos() as i32,
            }),
            updated_at: Some(prost_types::Timestamp {
                seconds: model.updated_at.timestamp(),
                nanos: model.updated_at.timestamp_subsec_nanos() as i32,
            }),
        }
    }
}

/// Convert CreateUserInput to SeaORM ActiveModel
impl From<CreateUserInput> for user::ActiveModel {
    fn from(input: CreateUserInput) -> Self {
        Self {
            email: Set(input.email),
            name: Set(input.name),
            bio: Set(input.bio),
            ..Default::default()
        }
    }
}

/// Extension trait for applying updates to an active model
pub trait ApplyUpdate<T> {
    fn apply_update(&mut self, input: T);
}

/// Apply UpdateUserInput to User ActiveModel
impl ApplyUpdate<UpdateUserInput> for user::ActiveModel {
    fn apply_update(&mut self, input: UpdateUserInput) {
        if let Some(email) = input.email {
            self.email = Set(email);
        }
        if let Some(name) = input.name {
            self.name = Set(name);
        }
        if let Some(bio) = input.bio {
            self.bio = Set(Some(bio));
        }
    }
}

// ============================================================================
// Post conversions
// ============================================================================

/// Convert SeaORM Post Model to proto Post
impl From<post::Model> for Post {
    fn from(model: post::Model) -> Self {
        Self {
            id: model.id,
            title: model.title,
            content: model.content,
            published: model.published,
            author_id: model.author_id,
            created_at: Some(prost_types::Timestamp {
                seconds: model.created_at.timestamp(),
                nanos: model.created_at.timestamp_subsec_nanos() as i32,
            }),
            updated_at: Some(prost_types::Timestamp {
                seconds: model.updated_at.timestamp(),
                nanos: model.updated_at.timestamp_subsec_nanos() as i32,
            }),
        }
    }
}

/// Convert CreatePostInput to SeaORM ActiveModel
impl From<CreatePostInput> for post::ActiveModel {
    fn from(input: CreatePostInput) -> Self {
        Self {
            title: Set(input.title),
            content: Set(input.content),
            published: Set(input.published),
            author_id: Set(input.author_id),
            ..Default::default()
        }
    }
}

/// Apply UpdatePostInput to Post ActiveModel
impl ApplyUpdate<UpdatePostInput> for post::ActiveModel {
    fn apply_update(&mut self, input: UpdatePostInput) {
        if let Some(title) = input.title {
            self.title = Set(title);
        }
        if let Some(content) = input.content {
            self.content = Set(content);
        }
        if let Some(published) = input.published {
            self.published = Set(published);
        }
    }
}
"#;

    std::fs::write(blog_dir.join("conversions.rs"), conversions_content)?;

    // NOTE: graphql/ module is now fully generated by protoc-gen-synapse
    // The graphql_schema.rs file has been removed - see src/generated/blog/graphql/mod.rs
    // REMOVED: ~600 lines of hardcoded GraphQL code

    // Override the generated storage implementations with filter/orderBy support
    let user_storage_impl = r#"//!SeaORM-based storage implementation for UserService
//! This file is manually generated by build.rs to add filter/orderBy support.
#![allow(missing_docs)]
#![allow(unused_imports)]
use super::prelude::*;
use super::user_service_storage::{UserServiceStorage, StorageError};
use super::conversions::ApplyUpdate;
use sea_orm::{
    ActiveModelTrait, ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter,
    QueryOrder, Set, Condition,
};

#[derive(Clone)]
pub struct SeaOrmUserServiceStorage {
    db: DatabaseConnection,
}

impl SeaOrmUserServiceStorage {
    pub fn new(db: DatabaseConnection) -> Self {
        Self { db }
    }
    pub fn db(&self) -> &DatabaseConnection {
        &self.db
    }
}

#[async_trait::async_trait]
impl UserServiceStorage for SeaOrmUserServiceStorage {
    async fn get_user(&self, request: GetUserRequest) -> Result<GetUserResponse, StorageError> {
        let model = user::Entity::find_by_id(request.id)
            .one(&self.db).await.map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(format!("User {} not found", request.id)))?;
        Ok(GetUserResponse { user: Some(model.into()) })
    }

    async fn list_users(&self, request: ListUsersRequest) -> Result<UserConnection, StorageError> {
        use sea_orm::QuerySelect;
        let limit = request.first.or(request.last).unwrap_or(20) as u64;
        let mut query = user::Entity::find();

        // Apply filters
        if let Some(ref filter) = request.filter {
            let mut cond = Condition::all();
            if let Some(ref f) = filter.id {
                if let Some(v) = f.eq { cond = cond.add(user::Column::Id.eq(v)); }
                if let Some(v) = f.ne { cond = cond.add(user::Column::Id.ne(v)); }
                if let Some(v) = f.gt { cond = cond.add(user::Column::Id.gt(v)); }
                if let Some(v) = f.gte { cond = cond.add(user::Column::Id.gte(v)); }
                if let Some(v) = f.lt { cond = cond.add(user::Column::Id.lt(v)); }
                if let Some(v) = f.lte { cond = cond.add(user::Column::Id.lte(v)); }
                if !f.r#in.is_empty() { cond = cond.add(user::Column::Id.is_in(f.r#in.clone())); }
            }
            if let Some(ref f) = filter.email {
                if let Some(ref v) = f.eq { cond = cond.add(user::Column::Email.eq(v.clone())); }
                if let Some(ref v) = f.contains { cond = cond.add(user::Column::Email.contains(v)); }
                if let Some(ref v) = f.starts_with { cond = cond.add(user::Column::Email.starts_with(v)); }
            }
            if let Some(ref f) = filter.name {
                if let Some(ref v) = f.eq { cond = cond.add(user::Column::Name.eq(v.clone())); }
                if let Some(ref v) = f.contains { cond = cond.add(user::Column::Name.contains(v)); }
            }
            query = query.filter(cond);
        }

        // Apply ordering
        let mut ordered = false;
        if let Some(ref o) = request.order_by {
            if let Some(d) = o.id { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::Id) } else { query.order_by_desc(user::Column::Id) }; }
            if let Some(d) = o.email { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::Email) } else { query.order_by_desc(user::Column::Email) }; }
            if let Some(d) = o.name { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::Name) } else { query.order_by_desc(user::Column::Name) }; }
            if let Some(d) = o.created_at { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::CreatedAt) } else { query.order_by_desc(user::Column::CreatedAt) }; }
            if let Some(d) = o.updated_at { ordered = true; query = if d == 1 { query.order_by_asc(user::Column::UpdatedAt) } else { query.order_by_desc(user::Column::UpdatedAt) }; }
        }
        if !ordered { query = query.order_by_asc(user::Column::Id); }

        // Cursor pagination
        if let Some(ref after) = request.after {
            if let Ok(id) = after.parse::<i64>() { query = query.filter(user::Column::Id.gt(id)); }
        }
        if let Some(ref before) = request.before {
            if let Ok(id) = before.parse::<i64>() { query = query.filter(user::Column::Id.lt(id)); }
        }

        let models = query.limit(limit + 1).all(&self.db).await.map_err(StorageError::Database)?;
        let has_next = models.len() > limit as usize;
        let models: Vec<_> = models.into_iter().take(limit as usize).collect();
        let edges: Vec<UserEdge> = models.into_iter().map(|m| UserEdge { cursor: m.id.to_string(), node: Some(m.into()) }).collect();
        let start = edges.first().map(|e| e.cursor.clone());
        let end = edges.last().map(|e| e.cursor.clone());
        Ok(UserConnection { edges, page_info: Some(PageInfo { has_next_page: has_next, has_previous_page: request.after.is_some(), start_cursor: start, end_cursor: end }) })
    }

    async fn create_user(&self, request: CreateUserRequest) -> Result<CreateUserResponse, StorageError> {
        let input = request.input.ok_or_else(|| StorageError::InvalidArgument("input required".into()))?;
        let active_model: user::ActiveModel = input.into();
        let model = active_model.insert(&self.db).await.map_err(StorageError::Database)?;
        Ok(CreateUserResponse { user: Some(model.into()) })
    }

    async fn update_user(&self, request: UpdateUserRequest) -> Result<UpdateUserResponse, StorageError> {
        use sea_orm::IntoActiveModel;
        let input = request.input.ok_or_else(|| StorageError::InvalidArgument("input required".into()))?;
        let model = user::Entity::find_by_id(request.id).one(&self.db).await.map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(format!("User {} not found", request.id)))?;
        let mut am = model.into_active_model();
        am.apply_update(input);
        let model = am.update(&self.db).await.map_err(StorageError::Database)?;
        Ok(UpdateUserResponse { user: Some(model.into()) })
    }

    async fn delete_user(&self, request: DeleteUserRequest) -> Result<DeleteUserResponse, StorageError> {
        let result = user::Entity::delete_by_id(request.id).exec(&self.db).await.map_err(StorageError::Database)?;
        Ok(DeleteUserResponse { success: result.rows_affected > 0 })
    }
}
"#;

    let post_storage_impl = r#"//!SeaORM-based storage implementation for PostService
//! This file is manually generated by build.rs to add filter/orderBy support.
#![allow(missing_docs)]
#![allow(unused_imports)]
use super::prelude::*;
use super::post_service_storage::{PostServiceStorage, StorageError};
use super::conversions::ApplyUpdate;
use sea_orm::{
    ActiveModelTrait, ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter,
    QueryOrder, Set, Condition,
};

#[derive(Clone)]
pub struct SeaOrmPostServiceStorage {
    db: DatabaseConnection,
}

impl SeaOrmPostServiceStorage {
    pub fn new(db: DatabaseConnection) -> Self {
        Self { db }
    }
    pub fn db(&self) -> &DatabaseConnection {
        &self.db
    }
}

#[async_trait::async_trait]
impl PostServiceStorage for SeaOrmPostServiceStorage {
    async fn get_post(&self, request: GetPostRequest) -> Result<GetPostResponse, StorageError> {
        let model = post::Entity::find_by_id(request.id)
            .one(&self.db).await.map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(format!("Post {} not found", request.id)))?;
        Ok(GetPostResponse { post: Some(model.into()) })
    }

    async fn list_posts(&self, request: ListPostsRequest) -> Result<PostConnection, StorageError> {
        use sea_orm::QuerySelect;
        let limit = request.first.or(request.last).unwrap_or(20) as u64;
        let mut query = post::Entity::find();

        // Apply filters
        if let Some(ref filter) = request.filter {
            let mut cond = Condition::all();
            if let Some(ref f) = filter.id {
                if let Some(v) = f.eq { cond = cond.add(post::Column::Id.eq(v)); }
                if let Some(v) = f.ne { cond = cond.add(post::Column::Id.ne(v)); }
                if let Some(v) = f.gt { cond = cond.add(post::Column::Id.gt(v)); }
                if !f.r#in.is_empty() { cond = cond.add(post::Column::Id.is_in(f.r#in.clone())); }
            }
            if let Some(ref f) = filter.title {
                if let Some(ref v) = f.eq { cond = cond.add(post::Column::Title.eq(v.clone())); }
                if let Some(ref v) = f.contains { cond = cond.add(post::Column::Title.contains(v)); }
            }
            if let Some(ref f) = filter.content {
                if let Some(ref v) = f.contains { cond = cond.add(post::Column::Content.contains(v)); }
            }
            if let Some(ref f) = filter.published {
                if let Some(v) = f.eq { cond = cond.add(post::Column::Published.eq(v)); }
            }
            if let Some(ref f) = filter.author_id {
                if let Some(v) = f.eq { cond = cond.add(post::Column::AuthorId.eq(v)); }
                if !f.r#in.is_empty() { cond = cond.add(post::Column::AuthorId.is_in(f.r#in.clone())); }
            }
            query = query.filter(cond);
        }

        // Apply ordering
        let mut ordered = false;
        if let Some(ref o) = request.order_by {
            if let Some(d) = o.id { ordered = true; query = if d == 1 { query.order_by_asc(post::Column::Id) } else { query.order_by_desc(post::Column::Id) }; }
            if let Some(d) = o.title { ordered = true; query = if d == 1 { query.order_by_asc(post::Column::Title) } else { query.order_by_desc(post::Column::Title) }; }
            if let Some(d) = o.published { ordered = true; query = if d == 1 { query.order_by_asc(post::Column::Published) } else { query.order_by_desc(post::Column::Published) }; }
            if let Some(d) = o.created_at { ordered = true; query = if d == 1 { query.order_by_asc(post::Column::CreatedAt) } else { query.order_by_desc(post::Column::CreatedAt) }; }
            if let Some(d) = o.updated_at { ordered = true; query = if d == 1 { query.order_by_asc(post::Column::UpdatedAt) } else { query.order_by_desc(post::Column::UpdatedAt) }; }
        }
        if !ordered { query = query.order_by_asc(post::Column::Id); }

        // Cursor pagination
        if let Some(ref after) = request.after {
            if let Ok(id) = after.parse::<i64>() { query = query.filter(post::Column::Id.gt(id)); }
        }
        if let Some(ref before) = request.before {
            if let Ok(id) = before.parse::<i64>() { query = query.filter(post::Column::Id.lt(id)); }
        }

        let models = query.limit(limit + 1).all(&self.db).await.map_err(StorageError::Database)?;
        let has_next = models.len() > limit as usize;
        let models: Vec<_> = models.into_iter().take(limit as usize).collect();
        let edges: Vec<PostEdge> = models.into_iter().map(|m| PostEdge { cursor: m.id.to_string(), node: Some(m.into()) }).collect();
        let start = edges.first().map(|e| e.cursor.clone());
        let end = edges.last().map(|e| e.cursor.clone());
        Ok(PostConnection { edges, page_info: Some(PageInfo { has_next_page: has_next, has_previous_page: request.after.is_some(), start_cursor: start, end_cursor: end }) })
    }

    async fn create_post(&self, request: CreatePostRequest) -> Result<CreatePostResponse, StorageError> {
        let input = request.input.ok_or_else(|| StorageError::InvalidArgument("input required".into()))?;
        let active_model: post::ActiveModel = input.into();
        let model = active_model.insert(&self.db).await.map_err(StorageError::Database)?;
        Ok(CreatePostResponse { post: Some(model.into()) })
    }

    async fn update_post(&self, request: UpdatePostRequest) -> Result<UpdatePostResponse, StorageError> {
        use sea_orm::IntoActiveModel;
        let input = request.input.ok_or_else(|| StorageError::InvalidArgument("input required".into()))?;
        let model = post::Entity::find_by_id(request.id).one(&self.db).await.map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(format!("Post {} not found", request.id)))?;
        let mut am = model.into_active_model();
        am.apply_update(input);
        let model = am.update(&self.db).await.map_err(StorageError::Database)?;
        Ok(UpdatePostResponse { post: Some(model.into()) })
    }

    async fn delete_post(&self, request: DeletePostRequest) -> Result<DeletePostResponse, StorageError> {
        let result = post::Entity::delete_by_id(request.id).exec(&self.db).await.map_err(StorageError::Database)?;
        Ok(DeletePostResponse { success: result.rows_affected > 0 })
    }
}
"#;

    // Write storage implementations (overwrites protoc-gen-synapse output)
    std::fs::write(blog_dir.join("sea_orm_user_service_storage.rs"), user_storage_impl)?;
    std::fs::write(blog_dir.join("sea_orm_post_service_storage.rs"), post_storage_impl)?;

    Ok(())
}
