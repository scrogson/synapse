use std::path::PathBuf;
use std::process::Command;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=proto/");
    println!("cargo:rerun-if-changed=../../protoc-gen-synapse/");

    let src_generated = PathBuf::from("src/generated");
    std::fs::create_dir_all(&src_generated)?;

    // FIRST: Generate the synapse types (filters, connections, etc.)
    // This must happen before tonic_build since iam.proto imports iam.synapse.proto
    let synapse_gen_status = Command::new("cargo")
        .args([
            "run",
            "--release",
            "--manifest-path",
            "../../synapse-proto-gen/Cargo.toml",
            "--",
            "proto/iam.entities.proto",
            "-I../../proto",
            "-Iproto",
            "-o",
            "proto/iam.synapse.proto",
        ])
        .status()?;

    if !synapse_gen_status.success() {
        println!("cargo:warning=Failed to generate synapse proto types");
        return Ok(());
    }

    // SECOND: Generate gRPC code with tonic (to OUT_DIR for include_proto!)
    // Now iam.synapse.proto exists
    tonic_build::configure()
        .build_server(true)
        .build_client(true)
        .compile_protos(
            &[
                "proto/iam.proto",
                "../../proto/synapse/relay/types.proto",
            ],
            &["proto/", "../../proto/"],
        )?;

    // THIRD: Build protoc-gen-synapse in release mode
    let build_status = Command::new("cargo")
        .args([
            "build",
            "--release",
            "--manifest-path",
            "../../protoc-gen-synapse/Cargo.toml",
        ])
        .status()?;

    if !build_status.success() {
        println!("cargo:warning=Failed to build protoc-gen-synapse");
        return Ok(());
    }

    // FOURTH: Run protoc with our plugin (to src/generated for direct imports)
    let status = Command::new("protoc")
        .args([
            "--plugin=protoc-gen-synapse=../../target/release/protoc-gen-synapse",
            &format!("--synapse_out=backend=seaorm:{}", src_generated.display()),
            "-I../../proto",
            "-Iproto",
            "proto/iam.proto",
        ])
        .status();

    match status {
        Ok(s) if s.success() => println!("cargo:warning=Synapse code generation succeeded"),
        Ok(s) => println!("cargo:warning=Synapse code generation failed with: {}", s),
        Err(e) => println!("cargo:warning=Failed to run protoc-gen-synapse: {}", e),
    }

    // Create the synapse module structure for relay types
    let synapse_dir = src_generated.join("synapse");
    let relay_dir = synapse_dir.join("relay");
    std::fs::create_dir_all(&relay_dir)?;

    std::fs::write(
        synapse_dir.join("mod.rs"),
        r#"//! Synapse generated types
//! @generated
#![allow(missing_docs)]
pub mod relay;
"#,
    )?;

    std::fs::write(
        relay_dir.join("mod.rs"),
        r#"//! Relay types (PageInfo, filters, etc.)
//! @generated
#![allow(missing_docs)]
#![allow(clippy::all)]
tonic::include_proto!("synapse.relay");
"#,
    )?;

    // Create a mod.rs file that includes all generated modules
    let mod_content = r#"//! Generated code from proto definitions
//!
//! This module is auto-generated by build.rs

#![allow(missing_docs)]
#![allow(unused_imports)]
#![allow(clippy::all)]
#![allow(dead_code)]

pub mod synapse;
pub mod iam;
"#;

    std::fs::write(src_generated.join("mod.rs"), mod_content)?;

    Ok(())
}
