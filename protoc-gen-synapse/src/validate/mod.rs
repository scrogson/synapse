//! Domain type generation from synapse.validate options
//!
//! This module generates validated domain types from protobuf messages
//! that have `(synapse.validate.message).generate_conversion = true`.
//!
//! Generated code includes:
//! - Domain type struct with validated fields
//! - ValidationError with `into_errors()` for rich error responses
//! - `TryFrom<ProtoMessage>` implementation with validation

use crate::error::GeneratorError;
use crate::options::synapse::validate;
use crate::storage::seaorm::options::{
    get_cached_validate_field_options, get_cached_validate_message_options,
};
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::TokenStream;
use prost_types::compiler::code_generator_response::File;
use prost_types::{FieldDescriptorProto, FileDescriptorProto};
use quote::{format_ident, quote};

/// Generate domain types for messages with validate options
pub fn generate(
    file: &FileDescriptorProto,
    message: &prost_types::DescriptorProto,
) -> Result<Option<File>, GeneratorError> {
    let file_name = file.name.as_deref().unwrap_or("");
    let message_name = message.name.as_deref().unwrap_or("");

    // Check if this message has validate options with generate_conversion
    let validate_options = match get_cached_validate_message_options(file_name, message_name) {
        Some(opts) if opts.generate_conversion && !opts.name.is_empty() => opts,
        _ => return Ok(None),
    };

    let domain_name = &validate_options.name;
    let proto_name = message_name;

    // Generate the output filename
    let module_name = domain_name.to_snake_case();
    let output_filename = format!(
        "{}/{}.rs",
        file.package.as_deref().unwrap_or("").replace('.', "/"),
        module_name
    );

    // Build identifiers
    let domain_ident = format_ident!("{}", domain_name);
    let proto_ident = format_ident!("{}", proto_name);
    let error_ident = format_ident!("{}ValidationError", domain_name);
    let field_error_ident = format_ident!("{}FieldError", domain_name);

    // Generate field definitions and validation
    let (field_defs, field_validations, field_assignments) =
        generate_fields(file_name, message_name, &message.field, &field_error_ident)?;

    // Build doc comments
    let module_doc = format!("Domain type {} generated from {}", domain_name, proto_name);
    let struct_doc = format!("Validated domain type for {}", proto_name);
    let error_doc = format!("Validation error for {} conversion", domain_name);

    // Generate field error type name
    let field_error_ident = format_ident!("{}FieldError", domain_name);

    let code = quote! {
        #![doc = #module_doc]
        //!
        //! Generated by protoc-gen-synapse from protobuf message definition.
        //! @generated

        #![allow(missing_docs)]
        #![allow(unused_imports)]

        use super::prelude::*;

        /// A single field validation error
        #[derive(Debug, Clone)]
        pub struct #field_error_ident {
            /// Error code (e.g., "required", "invalid_email", "min_length")
            pub code: String,
            /// Human-readable error message
            pub message: String,
            /// Field name that failed validation
            pub field: String,
        }

        impl std::fmt::Display for #field_error_ident {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{}: {}", self.field, self.message)
            }
        }

        impl std::error::Error for #field_error_ident {}

        #[doc = #struct_doc]
        #[derive(Debug, Clone)]
        pub struct #domain_ident {
            #(#field_defs)*
        }

        #[doc = #error_doc]
        #[derive(Debug)]
        pub struct #error_ident {
            errors: Vec<#field_error_ident>,
        }

        impl #error_ident {
            /// Convert validation errors to a list of field errors
            pub fn into_errors(self) -> Vec<#field_error_ident> {
                self.errors
            }

            /// Get a reference to the validation errors
            pub fn errors(&self) -> &[#field_error_ident] {
                &self.errors
            }
        }

        impl std::fmt::Display for #error_ident {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "validation failed: {} error(s)", self.errors.len())
            }
        }

        impl std::error::Error for #error_ident {}

        impl TryFrom<#proto_ident> for #domain_ident {
            type Error = #error_ident;

            fn try_from(request: #proto_ident) -> Result<Self, Self::Error> {
                let mut errors = Vec::new();

                #(#field_validations)*

                if !errors.is_empty() {
                    return Err(#error_ident { errors });
                }

                Ok(Self {
                    #(#field_assignments)*
                })
            }
        }
    };

    // Format the generated code
    let content = code.to_string();

    // Try to format with prettyplease if we can parse it
    let formatted = match syn::parse_file(&content) {
        Ok(parsed) => prettyplease::unparse(&parsed),
        Err(_) => content,
    };

    Ok(Some(File {
        name: Some(output_filename),
        content: Some(formatted),
        ..Default::default()
    }))
}

/// Generate field definitions, validations, and assignments
fn generate_fields(
    file_name: &str,
    message_name: &str,
    fields: &[FieldDescriptorProto],
    field_error_ident: &proc_macro2::Ident,
) -> Result<(Vec<TokenStream>, Vec<TokenStream>, Vec<TokenStream>), GeneratorError> {
    let mut field_defs = Vec::new();
    let mut field_validations = Vec::new();
    let mut field_assignments = Vec::new();

    for field in fields {
        let field_name = field.name.as_deref().unwrap_or("");
        let field_number = field.number.unwrap_or(0);
        let field_ident = format_ident!("{}", field_name.to_snake_case());

        // Look up field-level validate options
        let field_opts = get_cached_validate_field_options(file_name, message_name, field_number);

        // Skip this field if marked as skip
        if field_opts.as_ref().is_some_and(|opts| opts.skip) {
            continue;
        }

        // Check if field has custom type
        let custom_type = field_opts.as_ref().and_then(|opts| {
            if opts.r#type.is_empty() {
                None
            } else {
                Some(opts.r#type.clone())
            }
        });

        // Determine Rust type based on proto type or custom type
        let rust_type = if let Some(ref type_name) = custom_type {
            let type_ident = format_ident!("{}", type_name);
            quote! { #type_ident }
        } else {
            proto_type_to_rust(field)
        };

        // Generate field definition
        field_defs.push(quote! {
            pub #field_ident: #rust_type,
        });

        // Generate validation code based on field options
        if let Some(ref opts) = field_opts {
            if let Some(ref rules) = opts.rules {
                let validation = generate_field_validation(field_name, &field_ident, field, rules, field_error_ident);
                if !validation.is_empty() {
                    field_validations.push(validation);
                }
            }
        }

        // Generate field assignment (with type conversion if custom type)
        if custom_type.is_some() {
            let type_ident = format_ident!("{}", custom_type.unwrap());
            let field_name_str = field_name;
            field_assignments.push(quote! {
                #field_ident: #type_ident::from_str(&request.#field_ident)
                    .map_err(|e| errors.push(#field_error_ident {
                        code: "invalid_format".to_string(),
                        message: e.to_string(),
                        field: #field_name_str.to_string(),
                    }))
                    .unwrap_or_default(),
            });
        } else {
            field_assignments.push(quote! {
                #field_ident: request.#field_ident,
            });
        }
    }

    Ok((field_defs, field_validations, field_assignments))
}

/// Generate validation code for a field based on its rules
fn generate_field_validation(
    field_name: &str,
    field_ident: &proc_macro2::Ident,
    field: &FieldDescriptorProto,
    rules: &validate::Rules,
    field_error_ident: &proc_macro2::Ident,
) -> TokenStream {
    use prost_types::field_descriptor_proto::Type;

    let mut validations = Vec::new();
    let is_optional = field.proto3_optional.unwrap_or(false);
    let is_string = matches!(field.r#type(), Type::String);
    let is_bytes = matches!(field.r#type(), Type::Bytes);

    // Required validation
    if rules.required {
        if is_optional {
            // For optional fields, required means it must be Some
            validations.push(quote! {
                if request.#field_ident.is_none() {
                    errors.push(#field_error_ident {
                        code: "required".to_string(),
                        message: format!("{} is required", #field_name),
                        field: #field_name.to_string(),
                    });
                }
            });
        } else if is_string || is_bytes {
            // For strings/bytes, required means non-empty
            validations.push(quote! {
                if request.#field_ident.is_empty() {
                    errors.push(#field_error_ident {
                        code: "required".to_string(),
                        message: format!("{} is required", #field_name),
                        field: #field_name.to_string(),
                    });
                }
            });
        }
        // For numeric types, there's no meaningful "required" check since 0 is a valid value
        // The field is always present in proto3
    }

    // String-specific validations - only apply to string fields
    if is_string {
        // Email validation
        if rules.email {
            if is_optional {
                validations.push(quote! {
                    if let Some(ref value) = request.#field_ident {
                        if !value.is_empty() && !value.contains('@') {
                            errors.push(#field_error_ident {
                                code: "invalid_email".to_string(),
                                message: format!("{} must be a valid email address", #field_name),
                                field: #field_name.to_string(),
                            });
                        }
                    }
                });
            } else {
                validations.push(quote! {
                    if !request.#field_ident.is_empty() && !request.#field_ident.contains('@') {
                        errors.push(#field_error_ident {
                            code: "invalid_email".to_string(),
                            message: format!("{} must be a valid email address", #field_name),
                            field: #field_name.to_string(),
                        });
                    }
                });
            }
        }

        // Length validation
        if let Some(ref length) = rules.length {
            // Min length validation
            if length.min.is_some() && length.min.unwrap() > 0 {
                let min_val = length.min.unwrap() as usize;
                if is_optional {
                    validations.push(quote! {
                        if let Some(ref value) = request.#field_ident {
                            if value.len() < #min_val {
                                errors.push(#field_error_ident {
                                    code: "min_length".to_string(),
                                    message: format!("{} must be at least {} characters", #field_name, #min_val),
                                    field: #field_name.to_string(),
                                });
                            }
                        }
                    });
                } else {
                    validations.push(quote! {
                        if request.#field_ident.len() < #min_val {
                            errors.push(#field_error_ident {
                                code: "min_length".to_string(),
                                message: format!("{} must be at least {} characters", #field_name, #min_val),
                                field: #field_name.to_string(),
                            });
                        }
                    });
                }
            }

            // Max length validation
            if length.max.is_some() && length.max.unwrap() > 0 {
                let max_val = length.max.unwrap() as usize;
                if is_optional {
                    validations.push(quote! {
                        if let Some(ref value) = request.#field_ident {
                            if value.len() > #max_val {
                                errors.push(#field_error_ident {
                                    code: "max_length".to_string(),
                                    message: format!("{} must be at most {} characters", #field_name, #max_val),
                                    field: #field_name.to_string(),
                                });
                            }
                        }
                    });
                } else {
                    validations.push(quote! {
                        if request.#field_ident.len() > #max_val {
                            errors.push(#field_error_ident {
                                code: "max_length".to_string(),
                                message: format!("{} must be at most {} characters", #field_name, #max_val),
                                field: #field_name.to_string(),
                            });
                        }
                    });
                }
            }

            // Equal length validation
            if length.equal.is_some() && length.equal.unwrap() > 0 {
                let equal_val = length.equal.unwrap() as usize;
                if is_optional {
                    validations.push(quote! {
                        if let Some(ref value) = request.#field_ident {
                            if value.len() != #equal_val {
                                errors.push(#field_error_ident {
                                    code: "exact_length".to_string(),
                                    message: format!("{} must be exactly {} characters", #field_name, #equal_val),
                                    field: #field_name.to_string(),
                                });
                            }
                        }
                    });
                } else {
                    validations.push(quote! {
                        if request.#field_ident.len() != #equal_val {
                            errors.push(#field_error_ident {
                                code: "exact_length".to_string(),
                                message: format!("{} must be exactly {} characters", #field_name, #equal_val),
                                field: #field_name.to_string(),
                            });
                        }
                    });
                }
            }
        }

        // Pattern validation
        if !rules.pattern.is_empty() {
            let pattern = &rules.pattern;
            if is_optional {
                validations.push(quote! {
                    if let Some(ref value) = request.#field_ident {
                        let re = regex::Regex::new(#pattern).expect("invalid regex pattern");
                        if !re.is_match(value) {
                            errors.push(#field_error_ident {
                                code: "pattern".to_string(),
                                message: format!("{} does not match required pattern", #field_name),
                                field: #field_name.to_string(),
                            });
                        }
                    }
                });
            } else {
                validations.push(quote! {
                    {
                        let re = regex::Regex::new(#pattern).expect("invalid regex pattern");
                        if !re.is_match(&request.#field_ident) {
                            errors.push(#field_error_ident {
                                code: "pattern".to_string(),
                                message: format!("{} does not match required pattern", #field_name),
                                field: #field_name.to_string(),
                            });
                        }
                    }
                });
            }
        }
    }

    quote! {
        #(#validations)*
    }
}

/// Convert proto field type to Rust type token
fn proto_type_to_rust(field: &FieldDescriptorProto) -> TokenStream {
    use prost_types::field_descriptor_proto::Type;

    let is_optional = field.proto3_optional.unwrap_or(false);
    let is_repeated = field.label == Some(3); // LABEL_REPEATED

    let base_type = match field.r#type() {
        Type::Double => quote! { f64 },
        Type::Float => quote! { f32 },
        Type::Int64 | Type::Sfixed64 | Type::Sint64 => quote! { i64 },
        Type::Uint64 | Type::Fixed64 => quote! { u64 },
        Type::Int32 | Type::Sfixed32 | Type::Sint32 => quote! { i32 },
        Type::Uint32 | Type::Fixed32 => quote! { u32 },
        Type::Bool => quote! { bool },
        Type::String => quote! { String },
        Type::Bytes => quote! { Vec<u8> },
        Type::Message => {
            // Get the message type name
            let type_name = field.type_name.as_deref().unwrap_or("");
            let type_ident = format_ident!(
                "{}",
                type_name
                    .rsplit('.')
                    .next()
                    .unwrap_or(type_name)
                    .to_upper_camel_case()
            );
            quote! { #type_ident }
        }
        Type::Enum => {
            let type_name = field.type_name.as_deref().unwrap_or("");
            let type_ident = format_ident!(
                "{}",
                type_name
                    .rsplit('.')
                    .next()
                    .unwrap_or(type_name)
                    .to_upper_camel_case()
            );
            quote! { #type_ident }
        }
        _ => quote! { () },
    };

    if is_repeated {
        quote! { Vec<#base_type> }
    } else if is_optional {
        quote! { Option<#base_type> }
    } else {
        base_type
    }
}
