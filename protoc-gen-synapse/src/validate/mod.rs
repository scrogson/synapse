//! Domain type generation from synapse.validate options
//!
//! This module generates validated domain types from protobuf messages
//! that have `(synapse.validate.message).generate_conversion = true`.
//!
//! Generated code includes:
//! - Domain type struct with validated fields
//! - ValidationError with `into_errors()` for rich error responses
//! - `TryFrom<ProtoMessage>` implementation with validation

use crate::error::GeneratorError;
use crate::options::synapse::validate;
use crate::storage::seaorm::options::{
    get_cached_validate_field_options, get_cached_validate_message_options,
};
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::TokenStream;
use prost_types::compiler::code_generator_response::File;
use prost_types::{FieldDescriptorProto, FileDescriptorProto};
use quote::{format_ident, quote};

/// Generate domain types for messages with validate options
pub fn generate(
    file: &FileDescriptorProto,
    message: &prost_types::DescriptorProto,
) -> Result<Option<File>, GeneratorError> {
    let file_name = file.name.as_deref().unwrap_or("");
    let message_name = message.name.as_deref().unwrap_or("");

    // Check if this message has validate options with generate_conversion
    let validate_options = match get_cached_validate_message_options(file_name, message_name) {
        Some(opts) if opts.generate_conversion && !opts.name.is_empty() => opts,
        _ => return Ok(None),
    };

    let domain_name = &validate_options.name;
    let proto_name = message_name;

    // Generate the output filename
    let module_name = domain_name.to_snake_case();
    let output_filename = format!(
        "{}/{}.rs",
        file.package.as_deref().unwrap_or("").replace('.', "/"),
        module_name
    );

    // Generate field definitions and validation
    let (field_defs, field_validations, field_assignments) =
        generate_fields(file_name, message_name, &message.field)?;

    // Build identifiers
    let domain_ident = format_ident!("{}", domain_name);
    let proto_ident = format_ident!("{}", proto_name);
    let error_ident = format_ident!("{}ValidationError", domain_name);

    // Build doc comments
    let module_doc = format!("Domain type {} generated from {}", domain_name, proto_name);
    let struct_doc = format!("Validated domain type for {}", proto_name);
    let error_doc = format!("Validation error for {} conversion", domain_name);

    let code = quote! {
        #![doc = #module_doc]
        //!
        //! Generated by protoc-gen-synapse from protobuf message definition.
        //! @generated

        #![allow(missing_docs)]
        #![allow(unused_imports)]

        use super::prelude::*;

        #[doc = #struct_doc]
        #[derive(Debug, Clone)]
        pub struct #domain_ident {
            #(#field_defs)*
        }

        #[doc = #error_doc]
        #[derive(Debug)]
        pub struct #error_ident {
            errors: Vec<synapse::Error>,
        }

        impl #error_ident {
            /// Convert validation errors to synapse::Error list for rich error responses
            pub fn into_errors(self) -> Vec<synapse::Error> {
                self.errors
            }
        }

        impl std::fmt::Display for #error_ident {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "validation failed: {} error(s)", self.errors.len())
            }
        }

        impl std::error::Error for #error_ident {}

        impl TryFrom<#proto_ident> for #domain_ident {
            type Error = #error_ident;

            fn try_from(request: #proto_ident) -> Result<Self, Self::Error> {
                let mut errors = Vec::new();

                #(#field_validations)*

                if !errors.is_empty() {
                    return Err(#error_ident { errors });
                }

                Ok(Self {
                    #(#field_assignments)*
                })
            }
        }
    };

    // Format the generated code
    let content = code.to_string();

    // Try to format with prettyplease if we can parse it
    let formatted = match syn::parse_file(&content) {
        Ok(parsed) => prettyplease::unparse(&parsed),
        Err(_) => content,
    };

    Ok(Some(File {
        name: Some(output_filename),
        content: Some(formatted),
        ..Default::default()
    }))
}

/// Generate field definitions, validations, and assignments
fn generate_fields(
    file_name: &str,
    message_name: &str,
    fields: &[FieldDescriptorProto],
) -> Result<(Vec<TokenStream>, Vec<TokenStream>, Vec<TokenStream>), GeneratorError> {
    let mut field_defs = Vec::new();
    let mut field_validations = Vec::new();
    let mut field_assignments = Vec::new();

    for field in fields {
        let field_name = field.name.as_deref().unwrap_or("");
        let field_number = field.number.unwrap_or(0);
        let field_ident = format_ident!("{}", field_name.to_snake_case());

        // Look up field-level validate options
        let field_opts = get_cached_validate_field_options(file_name, message_name, field_number);

        // Skip this field if marked as skip
        if field_opts.as_ref().is_some_and(|opts| opts.skip) {
            continue;
        }

        // Check if field has custom type
        let custom_type = field_opts.as_ref().and_then(|opts| {
            if opts.r#type.is_empty() {
                None
            } else {
                Some(opts.r#type.clone())
            }
        });

        // Determine Rust type based on proto type or custom type
        let rust_type = if let Some(ref type_name) = custom_type {
            let type_ident = format_ident!("{}", type_name);
            quote! { #type_ident }
        } else {
            proto_type_to_rust(field)
        };

        // Generate field definition
        field_defs.push(quote! {
            pub #field_ident: #rust_type,
        });

        // Generate validation code based on field options
        if let Some(ref opts) = field_opts {
            if let Some(ref rules) = opts.rules {
                let validation = generate_field_validation(field_name, &field_ident, rules);
                if !validation.is_empty() {
                    field_validations.push(validation);
                }
            }
        }

        // Generate field assignment (with type conversion if custom type)
        if custom_type.is_some() {
            let type_ident = format_ident!("{}", custom_type.unwrap());
            let field_name_str = field_name;
            field_assignments.push(quote! {
                #field_ident: #type_ident::from_str(&request.#field_ident)
                    .map_err(|e| errors.push(synapse::Error {
                        code: "invalid_format".to_string(),
                        message: e.to_string(),
                        field: #field_name_str.to_string(),
                        details: Default::default(),
                    }))
                    .unwrap_or_default(),
            });
        } else {
            field_assignments.push(quote! {
                #field_ident: request.#field_ident,
            });
        }
    }

    Ok((field_defs, field_validations, field_assignments))
}

/// Generate validation code for a field based on its rules
fn generate_field_validation(
    field_name: &str,
    field_ident: &proc_macro2::Ident,
    rules: &validate::Rules,
) -> TokenStream {
    let mut validations = Vec::new();

    // Required validation (for strings: non-empty)
    if rules.required {
        validations.push(quote! {
            if request.#field_ident.is_empty() {
                errors.push(synapse::Error {
                    code: "required".to_string(),
                    message: format!("{} is required", #field_name),
                    field: #field_name.to_string(),
                    details: Default::default(),
                });
            }
        });
    }

    // Email validation
    if rules.email {
        validations.push(quote! {
            if !request.#field_ident.is_empty() && !request.#field_ident.contains('@') {
                errors.push(synapse::Error {
                    code: "invalid_email".to_string(),
                    message: format!("{} must be a valid email address", #field_name),
                    field: #field_name.to_string(),
                    details: Default::default(),
                });
            }
        });
    }

    // Length validation
    if let Some(ref length) = rules.length {
        // Only generate min validation if min is explicitly set and > 0
        if length.min.is_some() && length.min.unwrap() > 0 {
            let min_val = length.min.unwrap() as usize;
            validations.push(quote! {
                if request.#field_ident.len() < #min_val {
                    errors.push(synapse::Error {
                        code: "min_length".to_string(),
                        message: format!("{} must be at least {} characters", #field_name, #min_val),
                        field: #field_name.to_string(),
                        details: Default::default(),
                    });
                }
            });
        }
        // Only generate max validation if max is explicitly set and > 0
        if length.max.is_some() && length.max.unwrap() > 0 {
            let max_val = length.max.unwrap() as usize;
            validations.push(quote! {
                if request.#field_ident.len() > #max_val {
                    errors.push(synapse::Error {
                        code: "max_length".to_string(),
                        message: format!("{} must be at most {} characters", #field_name, #max_val),
                        field: #field_name.to_string(),
                        details: Default::default(),
                    });
                }
            });
        }
        // Only generate equal validation if equal is explicitly set and > 0
        if length.equal.is_some() && length.equal.unwrap() > 0 {
            let equal_val = length.equal.unwrap() as usize;
            validations.push(quote! {
                if request.#field_ident.len() != #equal_val {
                    errors.push(synapse::Error {
                        code: "exact_length".to_string(),
                        message: format!("{} must be exactly {} characters", #field_name, #equal_val),
                        field: #field_name.to_string(),
                        details: Default::default(),
                    });
                }
            });
        }
    }

    // Pattern validation
    if !rules.pattern.is_empty() {
        let pattern = &rules.pattern;
        validations.push(quote! {
            {
                let re = regex::Regex::new(#pattern).expect("invalid regex pattern");
                if !re.is_match(&request.#field_ident) {
                    errors.push(synapse::Error {
                        code: "pattern".to_string(),
                        message: format!("{} does not match required pattern", #field_name),
                        field: #field_name.to_string(),
                        details: Default::default(),
                    });
                }
            }
        });
    }

    // Custom error message override
    // Note: We don't use this directly here, but it could be used to override the message
    // in the generated code. For now, we use standard messages.

    quote! {
        #(#validations)*
    }
}

/// Convert proto field type to Rust type token
fn proto_type_to_rust(field: &FieldDescriptorProto) -> TokenStream {
    use prost_types::field_descriptor_proto::Type;

    let is_optional = field.proto3_optional.unwrap_or(false);
    let is_repeated = field.label == Some(3); // LABEL_REPEATED

    let base_type = match field.r#type() {
        Type::Double => quote! { f64 },
        Type::Float => quote! { f32 },
        Type::Int64 | Type::Sfixed64 | Type::Sint64 => quote! { i64 },
        Type::Uint64 | Type::Fixed64 => quote! { u64 },
        Type::Int32 | Type::Sfixed32 | Type::Sint32 => quote! { i32 },
        Type::Uint32 | Type::Fixed32 => quote! { u32 },
        Type::Bool => quote! { bool },
        Type::String => quote! { String },
        Type::Bytes => quote! { Vec<u8> },
        Type::Message => {
            // Get the message type name
            let type_name = field.type_name.as_deref().unwrap_or("");
            let type_ident = format_ident!(
                "{}",
                type_name
                    .rsplit('.')
                    .next()
                    .unwrap_or(type_name)
                    .to_upper_camel_case()
            );
            quote! { #type_ident }
        }
        Type::Enum => {
            let type_name = field.type_name.as_deref().unwrap_or("");
            let type_ident = format_ident!(
                "{}",
                type_name
                    .rsplit('.')
                    .next()
                    .unwrap_or(type_name)
                    .to_upper_camel_case()
            );
            quote! { #type_ident }
        }
        _ => quote! { () },
    };

    if is_repeated {
        quote! { Vec<#base_type> }
    } else if is_optional {
        quote! { Option<#base_type> }
    } else {
        base_type
    }
}
