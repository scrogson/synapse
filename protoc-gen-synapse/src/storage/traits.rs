//! Storage trait generation
//!
//! This module generates backend-agnostic Storage traits from protobuf service
//! definitions. The generated traits mirror service RPCs and can be implemented
//! by database storage layers or mocked for testing.
//!
//! The generated traits support partial overrides:
//! - A required `fn db()` method provides database access
//! - Each operation has a default implementation that calls `defaults::*`
//! - Users can override specific methods while using defaults for others

use super::seaorm::options::{
    get_cached_rpc_method_options, get_cached_service_options, get_cached_validate_message_options,
    parse_service_options,
};
use crate::error::GeneratorError;
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::TokenStream;
use prost_types::compiler::code_generator_response::File;
use prost_types::{FileDescriptorProto, MethodDescriptorProto, ServiceDescriptorProto};
use quote::{format_ident, quote};

/// Generate a Storage trait from a protobuf service
pub fn generate(
    file: &FileDescriptorProto,
    service: &ServiceDescriptorProto,
) -> Result<Option<File>, GeneratorError> {
    let file_name = file.name.as_deref().unwrap_or("");
    let service_name = service.name.as_deref().unwrap_or("");

    // Check if this service has storage options
    let service_options = match get_cached_service_options(file_name, service_name) {
        Some(opts) => opts,
        None => match parse_service_options(service) {
            Some(opts) => opts,
            None => return Ok(None), // No storage options, skip this service
        },
    };

    // Skip if explicitly marked or if generate_storage is false
    if service_options.skip || !service_options.generate_storage {
        return Ok(None);
    }

    // Determine trait name
    let trait_name = if service_options.trait_name.is_empty() {
        format!("{}Storage", service_name)
    } else {
        service_options.trait_name.clone()
    };

    // Check if we should generate default implementations
    let generate_defaults = service_options.generate_implementation;

    // Generate the output filename (in storage/ subdirectory)
    let module_name = trait_name.to_snake_case();
    let output_filename = format!(
        "{}/storage/{}.rs",
        file.package.as_deref().unwrap_or("").replace('.', "/"),
        module_name
    );

    // Generate trait methods (with or without default implementations)
    let methods = generate_trait_methods(file_name, service_name, &service.method, generate_defaults, &module_name)?;

    // Build the trait
    let trait_ident = format_ident!("{}", trait_name);

    // Build doc comment (quote! doesn't interpolate in doc comments)
    let module_doc = format!("Storage trait for {}", service_name);
    let trait_doc = format!(
        "Storage trait mirroring {} RPCs.\n\n\
        Implement the required `db()` method and optionally override any operations.\n\
        All operations have default implementations that delegate to the `defaults` module.",
        service_name
    );

    // Import the defaults module if we're generating default implementations
    let defaults_import = if generate_defaults {
        let defaults_module = format_ident!("{}_defaults", module_name);
        quote! {
            use super::#defaults_module as defaults;
        }
    } else {
        quote! {}
    };

    // The db() method - required for all implementations
    let db_method = if generate_defaults {
        quote! {
            /// Get a reference to the database connection.
            ///
            /// This is required for default implementations to work.
            fn db(&self) -> &sea_orm::DatabaseConnection;
        }
    } else {
        quote! {}
    };

    let code = quote! {
        #![doc = #module_doc]
        //!
        //! Generated by protoc-gen-synapse from protobuf service definition.
        //!
        //! This trait supports partial overrides - you can override specific methods
        //! while using default implementations for others. Just implement the required
        //! `db()` method and override the operations you need custom logic for.
        //!
        //! # Example
        //!
        //! ```rust,ignore
        //! struct MyStorage { db: DatabaseConnection }
        //!
        //! impl UserServiceStorage for MyStorage {
        //!     fn db(&self) -> &DatabaseConnection { &self.db }
        //!
        //!     // Override just create_user with custom business logic
        //!     async fn create_user(&self, request: CreateUserRequest) -> Result<CreateUserResponse, StorageError> {
        //!         // Custom validation
        //!         if request.email.is_empty() {
        //!             return Err(StorageError::InvalidArgument("email required".into()));
        //!         }
        //!
        //!         // Call default implementation
        //!         defaults::create_user(self.db(), request).await
        //!     }
        //!
        //!     // All other methods use trait defaults
        //! }
        //! ```
        //!
        //! @generated

        #![allow(missing_docs)]
        #![allow(unused_imports)]

        use super::super::prelude::*;
        #defaults_import

        /// Storage error type
        #[derive(Debug, thiserror::Error)]
        pub enum StorageError {
            /// Database error
            #[error("database error: {0}")]
            Database(#[from] sea_orm::DbErr),
            /// Resource not found
            #[error("not found: {0}")]
            NotFound(String),
            /// Invalid argument
            #[error("invalid argument: {0}")]
            InvalidArgument(String),
        }

        #[doc = #trait_doc]
        #[async_trait::async_trait]
        pub trait #trait_ident: Send + Sync {
            #db_method
            #(#methods)*
        }
    };

    // Format the generated code
    let content = code.to_string();

    // Try to format with prettyplease if we can parse it
    let formatted = match syn::parse_file(&content) {
        Ok(parsed) => prettyplease::unparse(&parsed),
        Err(_) => content, // If parsing fails, use unformatted
    };

    Ok(Some(File {
        name: Some(output_filename),
        content: Some(formatted),
        ..Default::default()
    }))
}

/// Generate trait method signatures from service methods
fn generate_trait_methods(
    file_name: &str,
    service_name: &str,
    methods: &[MethodDescriptorProto],
    generate_defaults: bool,
    _module_name: &str,
) -> Result<Vec<TokenStream>, GeneratorError> {
    let mut result = Vec::new();

    for method in methods {
        let method_name = method.name.as_deref().unwrap_or("");

        // Check for method-level options
        let method_options = get_cached_rpc_method_options(file_name, service_name, method_name);

        // Skip if marked
        if method_options.as_ref().map(|o| o.skip).unwrap_or(false) {
            continue;
        }

        // Determine Rust method name
        let rust_method_name = method_options
            .as_ref()
            .filter(|o| !o.method_name.is_empty())
            .map(|o| o.method_name.clone())
            .unwrap_or_else(|| method_name.to_snake_case());

        // Extract input/output types - check for domain type first
        let raw_input_type = extract_type_name(method.input_type.as_deref());
        let input_type = resolve_domain_type(file_name, &raw_input_type);
        let output_type = extract_type_name(method.output_type.as_deref());

        let method_ident = format_ident!("{}", rust_method_name);
        let input_ident = format_ident!("{}", input_type);
        let output_ident = format_ident!("{}", output_type);

        let method_token = if generate_defaults {
            // Generate method with default implementation that calls defaults::*
            quote! {
                async fn #method_ident(&self, request: #input_ident) -> Result<#output_ident, StorageError> {
                    defaults::#method_ident(self.db(), request).await
                }
            }
        } else {
            // Generate abstract method signature only
            quote! {
                async fn #method_ident(&self, request: #input_ident) -> Result<#output_ident, StorageError>;
            }
        };

        result.push(method_token);
    }

    Ok(result)
}

/// Resolve a message type to its domain type if one exists
///
/// If the message has synapse.validate.message options with generate_conversion=true
/// and a non-empty name, that name is used as the domain type. Otherwise, the
/// original message name is returned.
fn resolve_domain_type(file_name: &str, message_name: &str) -> String {
    if let Some(opts) = get_cached_validate_message_options(file_name, message_name) {
        if opts.generate_conversion && !opts.name.is_empty() {
            return opts.name.clone();
        }
    }
    message_name.to_string()
}

/// Extract a Rust type name from a protobuf type path
///
/// Converts ".package.name.TypeName" to "TypeName"
fn extract_type_name(type_name: Option<&str>) -> String {
    match type_name {
        Some(name) => {
            // Protobuf type names are like ".package.name.TypeName"
            // Extract just the type name (last segment)
            let type_part = name
                .rsplit('.')
                .next()
                .unwrap_or(name)
                .trim_start_matches('.');

            type_part.to_upper_camel_case()
        }
        None => "()".to_string(),
    }
}
