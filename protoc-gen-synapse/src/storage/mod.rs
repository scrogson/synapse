//! Storage trait generation
//!
//! This module generates backend-agnostic Storage traits from protobuf service
//! definitions. The generated traits mirror service RPCs and can be implemented
//! by database storage layers or mocked for testing.

use crate::backends::seaorm::options::{
    get_cached_rpc_method_options, get_cached_service_options, get_cached_validate_message_options,
    parse_service_options,
};
use crate::error::GeneratorError;
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::TokenStream;
use prost_types::compiler::code_generator_response::File;
use prost_types::{FileDescriptorProto, MethodDescriptorProto, ServiceDescriptorProto};
use quote::{format_ident, quote};

/// Generate a Storage trait from a protobuf service
pub fn generate(
    file: &FileDescriptorProto,
    service: &ServiceDescriptorProto,
) -> Result<Option<File>, GeneratorError> {
    let file_name = file.name.as_deref().unwrap_or("");
    let service_name = service.name.as_deref().unwrap_or("");

    // Check if this service has storage options
    let service_options = match get_cached_service_options(file_name, service_name) {
        Some(opts) => opts,
        None => match parse_service_options(service) {
            Some(opts) => opts,
            None => return Ok(None), // No storage options, skip this service
        },
    };

    // Skip if explicitly marked or if generate_storage is false
    if service_options.skip || !service_options.generate_storage {
        return Ok(None);
    }

    // Determine trait name
    let trait_name = if service_options.trait_name.is_empty() {
        format!("{}Storage", service_name)
    } else {
        service_options.trait_name.clone()
    };

    // Generate the output filename
    let module_name = trait_name.to_snake_case();
    let output_filename = format!(
        "{}/{}.rs",
        file.package.as_deref().unwrap_or("").replace('.', "/"),
        module_name
    );

    // Generate trait methods
    let methods = generate_trait_methods(file_name, service_name, &service.method)?;

    // Build the trait
    let trait_ident = format_ident!("{}", trait_name);

    // Build doc comment (quote! doesn't interpolate in doc comments)
    let module_doc = format!("Storage trait for {}", service_name);
    let trait_doc = format!("Storage trait mirroring {} RPCs", service_name);

    let code = quote! {
        #![doc = #module_doc]
        //!
        //! Generated by protoc-gen-synapse from protobuf service definition.
        //! @generated

        #![allow(missing_docs)]
        #![allow(unused_imports)]

        use super::prelude::*;

        /// Storage error type
        #[derive(Debug, thiserror::Error)]
        pub enum StorageError {
            /// Database error
            #[error("database error: {0}")]
            Database(#[from] sea_orm::DbErr),
            /// Resource not found
            #[error("not found: {0}")]
            NotFound(String),
            /// Invalid argument
            #[error("invalid argument: {0}")]
            InvalidArgument(String),
        }

        #[doc = #trait_doc]
        #[async_trait::async_trait]
        pub trait #trait_ident: Send + Sync {
            #(#methods)*
        }
    };

    // Format the generated code
    let content = code.to_string();

    // Try to format with prettyplease if we can parse it
    let formatted = match syn::parse_file(&content) {
        Ok(parsed) => prettyplease::unparse(&parsed),
        Err(_) => content, // If parsing fails, use unformatted
    };

    Ok(Some(File {
        name: Some(output_filename),
        content: Some(formatted),
        ..Default::default()
    }))
}

/// Generate trait method signatures from service methods
fn generate_trait_methods(
    file_name: &str,
    service_name: &str,
    methods: &[MethodDescriptorProto],
) -> Result<Vec<TokenStream>, GeneratorError> {
    let mut result = Vec::new();

    for method in methods {
        let method_name = method.name.as_deref().unwrap_or("");

        // Check for method-level options
        let method_options = get_cached_rpc_method_options(file_name, service_name, method_name);

        // Skip if marked
        if method_options.as_ref().map(|o| o.skip).unwrap_or(false) {
            continue;
        }

        // Determine Rust method name
        let rust_method_name = method_options
            .as_ref()
            .filter(|o| !o.method_name.is_empty())
            .map(|o| o.method_name.clone())
            .unwrap_or_else(|| method_name.to_snake_case());

        // Extract input/output types - check for domain type first
        let raw_input_type = extract_type_name(method.input_type.as_deref());
        let input_type = resolve_domain_type(file_name, &raw_input_type);
        let output_type = extract_type_name(method.output_type.as_deref());

        let method_ident = format_ident!("{}", rust_method_name);
        let input_ident = format_ident!("{}", input_type);
        let output_ident = format_ident!("{}", output_type);

        let method_token = quote! {
            async fn #method_ident(&self, request: #input_ident) -> Result<#output_ident, StorageError>;
        };

        result.push(method_token);
    }

    Ok(result)
}

/// Resolve a message type to its domain type if one exists
///
/// If the message has synapse.validate.message options with generate_conversion=true
/// and a non-empty name, that name is used as the domain type. Otherwise, the
/// original message name is returned.
fn resolve_domain_type(file_name: &str, message_name: &str) -> String {
    if let Some(opts) = get_cached_validate_message_options(file_name, message_name) {
        if opts.generate_conversion && !opts.name.is_empty() {
            return opts.name.clone();
        }
    }
    message_name.to_string()
}

/// Extract a Rust type name from a protobuf type path
///
/// Converts ".package.name.TypeName" to "TypeName"
fn extract_type_name(type_name: Option<&str>) -> String {
    match type_name {
        Some(name) => {
            // Protobuf type names are like ".package.name.TypeName"
            // Extract just the type name (last segment)
            let type_part = name
                .rsplit('.')
                .next()
                .unwrap_or(name)
                .trim_start_matches('.');

            type_part.to_upper_camel_case()
        }
        None => "()".to_string(),
    }
}
