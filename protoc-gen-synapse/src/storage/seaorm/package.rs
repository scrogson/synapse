//! Package module generation
//!
//! Generates the package-level mod.rs that wires together all generated code:
//! - tonic-generated gRPC code (via include_proto!)
//! - SeaORM entities
//! - Storage traits and implementations
//! - gRPC services
//! - GraphQL module
//! - Conversions

use super::options::{get_cached_entity_options, get_cached_service_options};
use crate::error::GeneratorError;
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::TokenStream;
use prost_types::compiler::code_generator_response::File;
use prost_types::FileDescriptorProto;
use quote::{format_ident, quote};

/// Information about what was generated for a package
pub struct PackageInfo {
    /// Entity modules (snake_case names)
    pub entities: Vec<String>,
    /// Service names
    pub services: Vec<String>,
}

/// Collect package information from a file descriptor
pub fn collect_package_info(file: &FileDescriptorProto) -> PackageInfo {
    let file_name = file.name.as_deref().unwrap_or("");
    let mut info = PackageInfo {
        entities: Vec::new(),
        services: Vec::new(),
    };

    // Collect entities
    for message in &file.message_type {
        let msg_name = message.name.as_deref().unwrap_or("");
        if let Some(opts) = get_cached_entity_options(file_name, msg_name) {
            if !opts.skip {
                info.entities.push(msg_name.to_string());
            }
        }
    }

    // Collect services
    for service in &file.service {
        let svc_name = service.name.as_deref().unwrap_or("");
        if let Some(opts) = get_cached_service_options(file_name, svc_name) {
            if !opts.skip {
                info.services.push(svc_name.to_string());
            }
        }
    }

    info
}

/// Generate the package mod.rs file
pub fn generate(file: &FileDescriptorProto) -> Result<Option<File>, GeneratorError> {
    let package = file.package.as_deref().unwrap_or("");
    if package.is_empty() {
        return Ok(None);
    }

    let info = collect_package_info(file);

    // Skip if no entities or services
    if info.entities.is_empty() && info.services.is_empty() {
        return Ok(None);
    }

    // Generate module declarations
    let mut mod_declarations = Vec::new();
    let mut pub_uses = Vec::new();

    // Entity modules
    for entity in &info.entities {
        let mod_name = format_ident!("{}", entity.to_snake_case());
        mod_declarations.push(quote! { pub mod #mod_name; });
    }

    // Storage trait modules
    for svc in &info.services {
        let trait_mod = format_ident!("{}_storage", svc.to_snake_case());
        mod_declarations.push(quote! { pub mod #trait_mod; });
    }

    // Storage implementation modules
    for svc in &info.services {
        let impl_mod = format_ident!("sea_orm_{}_storage", svc.to_snake_case());
        mod_declarations.push(quote! { pub mod #impl_mod; });
    }

    // gRPC service modules
    for svc in &info.services {
        let svc_mod = format_ident!("{}", svc.to_snake_case());
        mod_declarations.push(quote! { pub mod #svc_mod; });
    }

    // Conversions module
    mod_declarations.push(quote! { pub mod conversions; });

    // GraphQL module
    mod_declarations.push(quote! { pub mod graphql; });

    // Re-exports for entities
    for entity in &info.entities {
        let mod_name = format_ident!("{}", entity.to_snake_case());
        let model_alias = format_ident!("{}Model", entity.to_upper_camel_case());
        pub_uses.push(quote! {
            pub use #mod_name::Model as #model_alias;
        });
    }

    // Re-exports for storage traits and implementations
    for svc in &info.services {
        let svc_camel = svc.to_upper_camel_case();
        let trait_name = format_ident!("{}Storage", svc_camel);
        let impl_name = format_ident!("SeaOrm{}Storage", svc_camel);
        let grpc_name = format_ident!("{}GrpcService", svc_camel);
        let trait_mod = format_ident!("{}_storage", svc.to_snake_case());
        let impl_mod = format_ident!("sea_orm_{}_storage", svc.to_snake_case());
        let grpc_mod = format_ident!("{}", svc.to_snake_case());

        pub_uses.push(quote! { pub use #trait_mod::#trait_name; });
        pub_uses.push(quote! { pub use #impl_mod::#impl_name; });
        pub_uses.push(quote! { pub use #grpc_mod::#grpc_name; });
    }

    let code = quote! {
        //! Package module - combines tonic and synapse generated code
        //!
        //! This module is auto-generated by protoc-gen-synapse.
        //! @generated

        #![allow(missing_docs)]
        #![allow(unused_imports)]
        #![allow(clippy::all)]
        #![allow(dead_code)]

        // Include tonic-generated gRPC code (from OUT_DIR)
        tonic::include_proto!(#package);

        // Prelude for synapse-generated code
        pub mod prelude {
            pub use sea_orm::entity::prelude::*;
            pub use sea_orm::{DatabaseConnection, DbErr};

            // Re-export proto types from parent
            pub use super::*;

            /// Storage error type
            #[derive(Debug, thiserror::Error)]
            pub enum StorageError {
                #[error("database error: {0}")]
                Database(#[from] sea_orm::DbErr),
                #[error("not found: {0}")]
                NotFound(String),
                #[error("invalid argument: {0}")]
                InvalidArgument(String),
            }
        }

        // Sub-modules
        #(#mod_declarations)*

        // Re-exports
        #(#pub_uses)*
    };

    // Format the generated code
    let content = code.to_string();
    let formatted = match syn::parse_file(&content) {
        Ok(parsed) => prettyplease::unparse(&parsed),
        Err(_) => content,
    };

    // Output path
    let output_path = format!("{}/mod.rs", package.replace('.', "/"));

    Ok(Some(File {
        name: Some(output_path),
        content: Some(formatted),
        ..Default::default()
    }))
}

/// Generate the conversions.rs file with all From implementations
pub fn generate_conversions(file: &FileDescriptorProto) -> Result<Option<File>, GeneratorError> {
    let package = file.package.as_deref().unwrap_or("");

    if package.is_empty() {
        return Ok(None);
    }

    let info = collect_package_info(file);

    if info.entities.is_empty() {
        return Ok(None);
    }

    let mut conversions = Vec::new();

    for entity in &info.entities {
        let entity_mod = format_ident!("{}", entity.to_snake_case());
        let proto_type = format_ident!("{}", entity.to_upper_camel_case());
        let create_input = format_ident!("Create{}Input", entity.to_upper_camel_case());
        let update_input = format_ident!("Update{}Input", entity.to_upper_camel_case());

        // Find the entity message to get its fields
        let message = file.message_type.iter().find(|m| m.name.as_deref() == Some(entity));

        if let Some(msg) = message {
            // Generate Model -> Proto conversion
            let model_fields = generate_model_to_proto_fields(msg);

            conversions.push(quote! {
                /// Convert SeaORM Model to proto message
                impl From<#entity_mod::Model> for #proto_type {
                    fn from(model: #entity_mod::Model) -> Self {
                        Self {
                            #(#model_fields)*
                        }
                    }
                }
            });

            // Find CreateInput message
            let create_msg = file
                .message_type
                .iter()
                .find(|m| m.name.as_deref() == Some(&format!("Create{}Input", entity)));

            if let Some(create) = create_msg {
                let create_fields = generate_create_fields(create);
                conversions.push(quote! {
                    /// Convert CreateInput to SeaORM ActiveModel
                    impl From<#create_input> for #entity_mod::ActiveModel {
                        fn from(input: #create_input) -> Self {
                            use sea_orm::ActiveValue::Set;
                            Self {
                                #(#create_fields)*
                                ..Default::default()
                            }
                        }
                    }
                });
            }

            // Find UpdateInput message
            let update_msg = file
                .message_type
                .iter()
                .find(|m| m.name.as_deref() == Some(&format!("Update{}Input", entity)));

            if let Some(update) = update_msg {
                let update_fields = generate_update_fields(update, msg);
                conversions.push(quote! {
                    /// Apply UpdateInput to SeaORM ActiveModel
                    impl ApplyUpdate<#update_input> for #entity_mod::ActiveModel {
                        fn apply_update(&mut self, input: #update_input) {
                            use sea_orm::ActiveValue::Set;
                            #(#update_fields)*
                        }
                    }
                });
            }
        }
    }

    // Generate entity module imports
    let entity_imports: Vec<_> = info
        .entities
        .iter()
        .map(|e| {
            let mod_name = format_ident!("{}", e.to_snake_case());
            quote! { use super::#mod_name; }
        })
        .collect();

    let code = quote! {
        //! Conversions between proto types and SeaORM entities
        //!
        //! This module is auto-generated by protoc-gen-synapse.
        //! @generated

        #![allow(missing_docs)]
        #![allow(unused_imports)]

        use super::prelude::*;
        #(#entity_imports)*

        /// Extension trait for applying updates to an active model
        pub trait ApplyUpdate<T> {
            fn apply_update(&mut self, input: T);
        }

        #(#conversions)*
    };

    // Format the generated code
    let content = code.to_string();
    let formatted = match syn::parse_file(&content) {
        Ok(parsed) => prettyplease::unparse(&parsed),
        Err(_) => content,
    };

    // Output path
    let output_path = format!("{}/conversions.rs", package.replace('.', "/"));

    Ok(Some(File {
        name: Some(output_path),
        content: Some(formatted),
        ..Default::default()
    }))
}

/// Generate field assignments for Model -> Proto conversion
fn generate_model_to_proto_fields(message: &prost_types::DescriptorProto) -> Vec<TokenStream> {
    let mut fields = Vec::new();

    for field in &message.field {
        let field_name = field.name.as_deref().unwrap_or("");
        let rust_field = format_ident!("{}", field_name.to_snake_case());

        // Check if this is a Timestamp field
        let is_timestamp = field
            .type_name
            .as_ref()
            .map(|t| t.contains("Timestamp"))
            .unwrap_or(false);

        if is_timestamp {
            // SeaORM uses DateTime<Utc> which has .timestamp() directly
            fields.push(quote! {
                #rust_field: Some(prost_types::Timestamp {
                    seconds: model.#rust_field.timestamp(),
                    nanos: model.#rust_field.timestamp_subsec_nanos() as i32,
                }),
            });
        } else {
            fields.push(quote! {
                #rust_field: model.#rust_field,
            });
        }
    }

    fields
}

/// Generate field assignments for CreateInput -> ActiveModel conversion
fn generate_create_fields(message: &prost_types::DescriptorProto) -> Vec<TokenStream> {
    let mut fields = Vec::new();

    for field in &message.field {
        let field_name = field.name.as_deref().unwrap_or("");
        let rust_field = format_ident!("{}", field_name.to_snake_case());
        let is_optional = field.proto3_optional.unwrap_or(false);

        if is_optional {
            fields.push(quote! {
                #rust_field: Set(input.#rust_field),
            });
        } else {
            fields.push(quote! {
                #rust_field: Set(input.#rust_field),
            });
        }
    }

    fields
}

/// Generate field update assignments for UpdateInput -> ActiveModel
fn generate_update_fields(
    update_message: &prost_types::DescriptorProto,
    entity_message: &prost_types::DescriptorProto,
) -> Vec<TokenStream> {
    let mut fields = Vec::new();

    for field in &update_message.field {
        let field_name = field.name.as_deref().unwrap_or("");
        let rust_field = format_ident!("{}", field_name.to_snake_case());

        // Check if the corresponding field in the entity is optional
        let entity_field = entity_message
            .field
            .iter()
            .find(|f| f.name.as_deref() == Some(field_name));

        let is_optional_in_entity = entity_field
            .map(|f| f.proto3_optional.unwrap_or(false))
            .unwrap_or(false);

        // For optional entity fields, wrap value in Some()
        if is_optional_in_entity {
            fields.push(quote! {
                if let Some(value) = input.#rust_field {
                    self.#rust_field = Set(Some(value));
                }
            });
        } else {
            fields.push(quote! {
                if let Some(value) = input.#rust_field {
                    self.#rust_field = Set(value);
                }
            });
        }
    }

    fields
}
