//! Entity generation for SeaORM models
//!
//! This module generates the main entity struct with SeaORM 2.0 dense format.

use super::column;
use super::oneof::{
    extract_oneofs, generate_flatten_fields, generate_json_fields, generate_tagged_fields,
    is_oneof_field, OneofStrategy,
};
use super::options::{
    get_cached_column_options, get_cached_entity_options, parse_column_options,
    parse_entity_options,
};
use super::relation::generate_relation_fields;
use super::types::map_proto_type;
use crate::GeneratorError;
use heck::ToSnakeCase;
use proc_macro2::TokenStream;
use prost_types::compiler::code_generator_response::File;
use prost_types::field_descriptor_proto::Label;
use prost_types::{DescriptorProto, FieldDescriptorProto, FileDescriptorProto};
use quote::{format_ident, quote};

/// Generate a SeaORM entity file from a protobuf message
pub fn generate(
    file: &FileDescriptorProto,
    message: &DescriptorProto,
) -> Result<Option<File>, GeneratorError> {
    let file_name = file.name.as_deref().unwrap_or("");
    let msg_name = message.name.as_deref().unwrap_or("");

    // Check if this message has entity options
    // First try the cache (populated from prost-reflect), then fall back to prost-types parsing
    let entity_options = match get_cached_entity_options(file_name, msg_name) {
        Some(opts) => opts,
        None => match parse_entity_options(message) {
            Some(opts) => opts,
            None => return Ok(None), // No entity options, skip this message
        },
    };

    // Skip if explicitly marked
    if entity_options.skip {
        return Ok(None);
    }

    // Get message name
    let message_name = message
        .name
        .as_ref()
        .ok_or_else(|| GeneratorError::CodeGenError("Message has no name".to_string()))?;

    // Determine table name
    let table_name = if entity_options.table_name.is_empty() {
        message_name.to_snake_case()
    } else {
        entity_options.table_name.clone()
    };

    // Generate the output filename (in entities/ subdirectory)
    let module_name = message_name.to_snake_case();
    let output_filename = format!(
        "{}/entities/{}.rs",
        file.package.as_deref().unwrap_or("").replace('.', "/"),
        module_name
    );

    // Generate field definitions
    let fields = generate_fields(message, file_name, msg_name)?;

    // Generate oneof fields
    let oneof_fields = generate_oneof_fields(message);

    // Generate relation fields from entity options
    let relation_fields = generate_relation_fields(&entity_options.relations, &message_name);

    // Build the entity struct
    let struct_name = format_ident!("Model");
    let table_name_lit = &table_name;

    let field_tokens: Vec<_> = fields
        .iter()
        .map(|f| {
            let name = format_ident!("{}", f.name);
            let ty: syn::Type = syn::parse_str(&f.rust_type).unwrap_or_else(|_| {
                // Fallback to parsing as a simple path
                syn::parse_str::<syn::Type>(&f.rust_type.to_string())
                    .unwrap_or_else(|_| syn::parse_quote!(String))
            });

            let attrs = &f.attributes;
            if attrs.is_empty() {
                quote! {
                    pub #name: #ty
                }
            } else {
                let attr_tokens: Vec<proc_macro2::TokenStream> = attrs
                    .iter()
                    .map(|a| {
                        let attr_content: proc_macro2::TokenStream = a.parse().unwrap();
                        quote! { #[sea_orm(#attr_content)] }
                    })
                    .collect();
                quote! {
                    #(#attr_tokens)*
                    pub #name: #ty
                }
            }
        })
        .collect();

    // Combine regular fields, oneof fields, and relation fields
    let all_field_tokens: Vec<TokenStream> = field_tokens
        .into_iter()
        .chain(oneof_fields)
        .chain(relation_fields)
        .collect();

    let code = quote! {
        //! SeaORM entity for the table
        //!
        //! Generated by protoc-gen-synapse from protobuf definition.
        //! @generated

        #![allow(missing_docs)]
        #![allow(unused_imports)]

        use super::super::prelude::*;
        use sea_orm::entity::prelude::*;

        #[sea_orm::model]
        #[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
        #[sea_orm(table_name = #table_name_lit)]
        pub struct #struct_name {
            #(#all_field_tokens),*
        }

        impl ActiveModelBehavior for ActiveModel {}
    };

    // Format the generated code
    let content = code.to_string();

    // Try to format with prettyplease if we can parse it
    let formatted = match syn::parse_file(&content) {
        Ok(parsed) => prettyplease::unparse(&parsed),
        Err(_) => content, // If parsing fails, use unformatted
    };

    Ok(Some(File {
        name: Some(output_filename),
        content: Some(formatted),
        ..Default::default()
    }))
}

/// Generated field information
struct GeneratedField {
    name: String,
    rust_type: String,
    attributes: Vec<String>,
}

/// Generate field definitions from message fields
fn generate_fields(
    message: &DescriptorProto,
    file_name: &str,
    msg_name: &str,
) -> Result<Vec<GeneratedField>, GeneratorError> {
    let mut fields = Vec::new();

    for field in &message.field {
        let field_name = field
            .name
            .as_ref()
            .ok_or_else(|| GeneratorError::CodeGenError("Field has no name".to_string()))?;

        let field_number = field.number.unwrap_or(0);

        // Get column options - first try cache, then fall back to prost-types parsing
        let column_options = get_cached_column_options(file_name, msg_name, field_number)
            .or_else(|| parse_column_options(field));

        // Skip oneof fields (they're handled by generate_oneof_fields)
        if is_oneof_field(field, message) {
            continue;
        }

        // Determine the Rust type
        let proto_type = field.r#type();
        let type_name = field.type_name.as_deref();
        let mapped = map_proto_type(proto_type, type_name);

        // Check if the field is nullable
        let is_nullable = is_field_nullable(field);

        // Check if this is an embedded field (stored as JSON)
        let is_embedded = column_options.as_ref().map(|o| o.embed).unwrap_or(false);

        // Build the final Rust type
        let rust_type = if is_embedded {
            // Embedded fields are stored as typed JSON
            // In SeaORM 2.0, use the type directly with column_type = "JsonBinary"
            // The type should derive FromJsonQueryResult
            let inner_type = extract_embedded_type_name(type_name);
            if is_nullable {
                format!("Option<{}>", inner_type)
            } else {
                inner_type
            }
        } else if is_nullable && !mapped.rust_type.starts_with("Option<") {
            format!("Option<{}>", mapped.rust_type)
        } else {
            mapped.rust_type.clone()
        };

        // Override type if specified in options (but not for embedded fields)
        let rust_type = if !is_embedded {
            if let Some(ref opts) = column_options {
                if !opts.column_type.is_empty() {
                    map_column_type_to_rust(&opts.column_type, is_nullable)
                } else {
                    rust_type
                }
            } else {
                rust_type
            }
        } else {
            rust_type
        };

        // Generate attributes using the column module
        let col_attrs = column::generate_attributes(column_options.as_ref(), &mapped, is_nullable);

        // Use snake_case for field name
        let snake_name = field_name.to_snake_case();

        fields.push(GeneratedField {
            name: snake_name,
            rust_type,
            attributes: col_attrs.attributes,
        });
    }

    Ok(fields)
}

/// Generate fields for all oneofs in a message
fn generate_oneof_fields(message: &DescriptorProto) -> Vec<TokenStream> {
    let oneofs = extract_oneofs(message);
    let mut fields = Vec::new();

    for oneof in oneofs {
        let oneof_fields = match oneof.strategy {
            OneofStrategy::Flatten => generate_flatten_fields(&oneof, message),
            OneofStrategy::Json => generate_json_fields(&oneof),
            OneofStrategy::Tagged => generate_tagged_fields(&oneof),
        };
        fields.extend(oneof_fields);
    }

    fields
}

/// Determine if a field should be nullable based on proto definition
fn is_field_nullable(field: &FieldDescriptorProto) -> bool {
    // In proto3, repeated fields are never nullable (they're empty arrays)
    let label = field.label();
    if label == Label::Repeated {
        return false;
    }

    // Check if it's proto3 optional
    field.proto3_optional.unwrap_or(false)
}

/// Map a SeaORM column type string to a Rust type
fn map_column_type_to_rust(column_type: &str, is_nullable: bool) -> String {
    let base_type = match column_type.to_lowercase().as_str() {
        "uuid" => "Uuid",
        "json" | "jsonb" => "Json",
        "text" => "String",
        "integer" | "int" => "i32",
        "bigint" | "biginteger" => "i64",
        "smallint" | "smallinteger" => "i16",
        "float" => "f32",
        "double" => "f64",
        "decimal" => "Decimal",
        "boolean" | "bool" => "bool",
        "date" => "Date",
        "time" => "Time",
        "datetime" => "DateTime",
        "timestamp" | "timestampwithtimezone" => "DateTimeUtc",
        "binary" | "blob" | "varbinary" => "Vec<u8>",
        _ => column_type, // Use as-is if unknown
    };

    if is_nullable {
        format!("Option<{}>", base_type)
    } else {
        base_type.to_string()
    }
}

/// Extract the Rust type name for an embedded field from the protobuf type_name
///
/// Converts protobuf type names like `.test.models.Metadata` to Rust type names like `Metadata`.
/// The type is expected to be defined elsewhere (e.g., in the same module or imported).
fn extract_embedded_type_name(type_name: Option<&str>) -> String {
    match type_name {
        Some(name) => {
            // Protobuf type names are like ".package.name.TypeName"
            // Extract just the type name (last segment) and convert to PascalCase
            let type_part = name
                .rsplit('.')
                .next()
                .unwrap_or(name)
                .trim_start_matches('.');

            // Convert to PascalCase for Rust convention
            use heck::ToUpperCamelCase;
            type_part.to_upper_camel_case()
        }
        None => "serde_json::Value".to_string(), // Fallback for unknown types
    }
}
