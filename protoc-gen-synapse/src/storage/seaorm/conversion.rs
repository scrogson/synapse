//! Conversion generation between proto types and SeaORM entities
//!
//! This module generates:
//! - `From<entity::Model>` for proto message types (entity -> proto)
//! - `From<CreateInput>` for `entity::ActiveModel` (proto -> active model)
//! - `ApplyUpdate` trait implementation for update inputs

#![allow(dead_code)]

use super::options::{get_cached_column_options, get_cached_entity_options};
use crate::error::GeneratorError;
use heck::ToSnakeCase;
use proc_macro2::TokenStream;
use prost_types::compiler::code_generator_response::File;
use prost_types::{DescriptorProto, FieldDescriptorProto, FileDescriptorProto};
use quote::{format_ident, quote};

/// Generate conversion implementations for an entity
pub fn generate(
    file: &FileDescriptorProto,
    message: &DescriptorProto,
) -> Result<Option<File>, GeneratorError> {
    let file_name = file.name.as_deref().unwrap_or("");
    let message_name = message.name.as_deref().unwrap_or("");

    // Check if this message has entity options
    let entity_options = match get_cached_entity_options(file_name, message_name) {
        Some(opts) => opts,
        None => return Ok(None),
    };

    // Skip if explicitly marked
    if entity_options.skip {
        return Ok(None);
    }

    let entity_module = format_ident!("{}", message_name.to_snake_case());
    let proto_type = format_ident!("{}", message_name);

    // Generate field conversions for Model -> Proto
    let model_to_proto_fields = generate_model_to_proto_fields(file_name, message)?;

    // Generate the output filename
    let output_filename = format!(
        "{}/{}_conversions.rs",
        file.package.as_deref().unwrap_or("").replace('.', "/"),
        message_name.to_snake_case()
    );

    let module_doc = format!("Conversion implementations for {}", message_name);

    let code = quote! {
        #![doc = #module_doc]
        //!
        //! Generated by protoc-gen-synapse from protobuf definition.
        //! @generated

        #![allow(missing_docs)]
        #![allow(unused_imports)]

        use super::prelude::*;
        use super::#entity_module;

        /// Convert SeaORM Model to proto message
        impl From<#entity_module::Model> for #proto_type {
            fn from(model: #entity_module::Model) -> Self {
                Self {
                    #(#model_to_proto_fields)*
                }
            }
        }
    };

    // Format the generated code
    let content = code.to_string();

    let formatted = match syn::parse_file(&content) {
        Ok(parsed) => prettyplease::unparse(&parsed),
        Err(_) => content,
    };

    Ok(Some(File {
        name: Some(output_filename),
        content: Some(formatted),
        ..Default::default()
    }))
}

/// Generate field assignments for Model -> Proto conversion
fn generate_model_to_proto_fields(
    file_name: &str,
    message: &DescriptorProto,
) -> Result<Vec<TokenStream>, GeneratorError> {
    let message_name = message.name.as_deref().unwrap_or("");
    let mut fields = Vec::new();

    for field in &message.field {
        let field_name = field.name.as_deref().unwrap_or("");
        let field_number = field.number.unwrap_or(0);
        let rust_field = format_ident!("{}", field_name.to_snake_case());

        // Check for column options (skip certain fields)
        let _column_options = get_cached_column_options(file_name, message_name, field_number);

        // Handle timestamp fields specially
        if is_timestamp_field(field) {
            let conversion = quote! {
                #rust_field: Some(prost_types::Timestamp {
                    seconds: model.#rust_field.and_utc().timestamp(),
                    nanos: model.#rust_field.and_utc().timestamp_subsec_nanos() as i32,
                }),
            };
            fields.push(conversion);
        } else if is_optional_field(field) {
            // Optional fields map directly
            let conversion = quote! {
                #rust_field: model.#rust_field,
            };
            fields.push(conversion);
        } else {
            // Regular fields
            let conversion = quote! {
                #rust_field: model.#rust_field,
            };
            fields.push(conversion);
        }
    }

    Ok(fields)
}

/// Check if a field is a timestamp type
fn is_timestamp_field(field: &FieldDescriptorProto) -> bool {
    field
        .type_name
        .as_ref()
        .map(|t| t.ends_with(".google.protobuf.Timestamp"))
        .unwrap_or(false)
}

/// Check if a field is optional
fn is_optional_field(field: &FieldDescriptorProto) -> bool {
    field.proto3_optional.unwrap_or(false)
}

/// Generate input conversion implementations for create/update inputs
pub fn generate_input_conversions(
    file: &FileDescriptorProto,
    entity_message: &DescriptorProto,
    input_messages: &[&DescriptorProto],
) -> Result<Option<File>, GeneratorError> {
    let file_name = file.name.as_deref().unwrap_or("");
    let entity_name = entity_message.name.as_deref().unwrap_or("");

    // Check if this message has entity options
    let entity_options = match get_cached_entity_options(file_name, entity_name) {
        Some(opts) => opts,
        None => return Ok(None),
    };

    if entity_options.skip {
        return Ok(None);
    }

    let entity_module = format_ident!("{}", entity_name.to_snake_case());
    let mut conversions = Vec::new();

    for input_msg in input_messages {
        let input_name = input_msg.name.as_deref().unwrap_or("");

        if input_name.starts_with("Create") && input_name.ends_with("Input") {
            // CreateXxxInput -> ActiveModel
            let input_ident = format_ident!("{}", input_name);
            let field_sets = generate_create_field_sets(input_msg);

            conversions.push(quote! {
                impl From<#input_ident> for #entity_module::ActiveModel {
                    fn from(input: #input_ident) -> Self {
                        Self {
                            #(#field_sets)*
                            ..Default::default()
                        }
                    }
                }
            });
        } else if input_name.starts_with("Update") && input_name.ends_with("Input") {
            // UpdateXxxInput -> apply_update method
            let input_ident = format_ident!("{}", input_name);
            let field_updates = generate_update_field_sets(input_msg);

            conversions.push(quote! {
                /// Extension trait for applying updates to an active model
                pub trait ApplyUpdate<T> {
                    fn apply_update(&mut self, input: T);
                }

                impl ApplyUpdate<#input_ident> for #entity_module::ActiveModel {
                    fn apply_update(&mut self, input: #input_ident) {
                        #(#field_updates)*
                    }
                }
            });
        }
    }

    if conversions.is_empty() {
        return Ok(None);
    }

    let output_filename = format!(
        "{}/{}_input_conversions.rs",
        file.package.as_deref().unwrap_or("").replace('.', "/"),
        entity_name.to_snake_case()
    );

    let module_doc = format!("Input conversion implementations for {}", entity_name);

    let code = quote! {
        #![doc = #module_doc]
        //!
        //! Generated by protoc-gen-synapse from protobuf definition.
        //! @generated

        #![allow(missing_docs)]
        #![allow(unused_imports)]

        use super::prelude::*;
        use super::#entity_module;
        use sea_orm::ActiveValue::Set;

        #(#conversions)*
    };

    let content = code.to_string();

    let formatted = match syn::parse_file(&content) {
        Ok(parsed) => prettyplease::unparse(&parsed),
        Err(_) => content,
    };

    Ok(Some(File {
        name: Some(output_filename),
        content: Some(formatted),
        ..Default::default()
    }))
}

/// Generate field Set statements for create input
fn generate_create_field_sets(input_msg: &DescriptorProto) -> Vec<TokenStream> {
    let mut fields = Vec::new();

    for field in &input_msg.field {
        let field_name = field.name.as_deref().unwrap_or("");
        let rust_field = format_ident!("{}", field_name.to_snake_case());

        if is_optional_field(field) {
            // Optional fields use Set with the Option value
            fields.push(quote! {
                #rust_field: input.#rust_field.map(Set).unwrap_or_default(),
            });
        } else {
            // Required fields use Set
            fields.push(quote! {
                #rust_field: Set(input.#rust_field),
            });
        }
    }

    fields
}

/// Generate field update statements for update input
fn generate_update_field_sets(input_msg: &DescriptorProto) -> Vec<TokenStream> {
    let mut fields = Vec::new();

    for field in &input_msg.field {
        let field_name = field.name.as_deref().unwrap_or("");
        let rust_field = format_ident!("{}", field_name.to_snake_case());

        // All update input fields should be optional - only set if Some
        fields.push(quote! {
            if let Some(value) = input.#rust_field {
                self.#rust_field = Set(value);
            }
        });
    }

    fields
}
