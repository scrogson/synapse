//! Storage implementation generation
//!
//! This module generates SeaORM-based implementations of storage traits.
//! The generated implementations bridge between gRPC request/response types
//! and SeaORM entities, handling CRUD operations.

use super::options::{get_cached_service_options, storage};
use crate::error::GeneratorError;
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::TokenStream;
use prost_types::compiler::code_generator_response::File;
use prost_types::{DescriptorProto, FileDescriptorProto, ServiceDescriptorProto};
use quote::{format_ident, quote};

/// Generate a SeaORM-based storage implementation from a protobuf service
///
/// The generated implementation:
/// - Provides a `new(db)` constructor
/// - Implements the required `db()` method from the trait
/// - Uses all default trait method implementations
///
/// This minimal implementation serves as a ready-to-use storage backend.
/// For custom business logic, users should create their own type implementing
/// the trait with the same pattern.
pub fn generate(
    file: &FileDescriptorProto,
    service: &ServiceDescriptorProto,
    _all_files: &[FileDescriptorProto],
) -> Result<Option<File>, GeneratorError> {
    let file_name = file.name.as_deref().unwrap_or("");
    let service_name = service.name.as_deref().unwrap_or("");

    // Check if this service has storage options with generate_implementation
    let service_options = match get_cached_service_options(file_name, service_name) {
        Some(opts) => opts,
        None => return Ok(None),
    };

    // Skip if explicitly marked or if generate_storage is false
    if service_options.skip || !service_options.generate_storage {
        return Ok(None);
    }

    // Skip if generate_implementation is false
    if !service_options.generate_implementation {
        return Ok(None);
    }

    // Determine trait name
    let trait_name = if service_options.trait_name.is_empty() {
        format!("{}Storage", service_name)
    } else {
        service_options.trait_name.clone()
    };

    // Generate the output filename (in storage/ subdirectory)
    let impl_name = format!("SeaOrm{}", trait_name);
    let module_name = impl_name.to_snake_case();
    let output_filename = format!(
        "{}/storage/{}.rs",
        file.package.as_deref().unwrap_or("").replace('.', "/"),
        module_name
    );

    // Build identifiers
    let impl_ident = format_ident!("{}", impl_name);
    let trait_ident = format_ident!("{}", trait_name);

    // Build doc comment
    let module_doc = format!("SeaORM-based storage implementation for {}", service_name);
    let struct_doc = format!(
        "SeaORM-based implementation of {} using DatabaseConnection.\n\n\
        This implementation uses all default trait methods. For custom business logic,\n\
        create your own type implementing {} and override the methods you need.",
        trait_name, trait_name
    );

    // Import the storage trait module
    let trait_module = format_ident!("{}", trait_name.to_snake_case());

    let code = quote! {
        #![doc = #module_doc]
        //!
        //! Generated by protoc-gen-synapse from protobuf service definition.
        //!
        //! This implementation uses all default trait methods from the trait.
        //! For custom business logic, create your own struct implementing the trait
        //! and override only the methods you need.
        //!
        //! @generated

        #![allow(missing_docs)]
        #![allow(unused_imports)]

        use super::#trait_module::#trait_ident;
        use sea_orm::DatabaseConnection;

        #[doc = #struct_doc]
        #[derive(Clone)]
        pub struct #impl_ident {
            db: DatabaseConnection,
        }

        impl #impl_ident {
            /// Create a new storage implementation with the given database connection
            pub fn new(db: DatabaseConnection) -> Self {
                Self { db }
            }
        }

        #[async_trait::async_trait]
        impl #trait_ident for #impl_ident {
            fn db(&self) -> &DatabaseConnection {
                &self.db
            }
            // All other methods use trait defaults
        }
    };

    // Format the generated code
    let content = code.to_string();

    // Try to format with prettyplease if we can parse it
    let formatted = match syn::parse_file(&content) {
        Ok(parsed) => prettyplease::unparse(&parsed),
        Err(_) => content, // If parsing fails, use unformatted
    };

    Ok(Some(File {
        name: Some(output_filename),
        content: Some(formatted),
        ..Default::default()
    }))
}

// =============================================================================
// Public helper functions for generating method implementations
// These are used by the defaults module generator to create standalone functions
// =============================================================================

/// Generate a GET implementation
///
/// If `for_standalone` is true, generates code using `db` parameter instead of `self.db`
pub fn generate_get_impl(
    entity_module: &proc_macro2::Ident,
    response_ident: &proc_macro2::Ident,
    _entity_options: Option<&storage::EntityOptions>,
    for_standalone: bool,
) -> TokenStream {
    // Derive the entity type name (e.g., user -> User)
    let entity_type = format_ident!("{}", entity_module.to_string().to_upper_camel_case());

    let db_ref = if for_standalone {
        quote! { db }
    } else {
        quote! { &self.db }
    };

    quote! {
        let model = entities::#entity_module::Entity::find_by_id(request.id)
            .one(#db_ref)
            .await
            .map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(format!("{} with id {} not found", stringify!(#entity_type), request.id)))?;

        Ok(#response_ident {
            #entity_module: Some(model.into()),
        })
    }
}

/// Generate a LIST implementation with filter/orderBy support
///
/// If `for_standalone` is true, generates code using `db` parameter instead of `self.db`
pub fn generate_list_impl(
    file: &FileDescriptorProto,
    request_type: &str,
    entity_module: &proc_macro2::Ident,
    response_ident: &proc_macro2::Ident,
    all_files: &[FileDescriptorProto],
    for_standalone: bool,
) -> TokenStream {
    // Derive the edge type name (e.g., user -> UserEdge)
    let entity_type = entity_module.to_string().to_upper_camel_case();
    let edge_ident = format_ident!("{}Edge", entity_type);

    let db_ref = if for_standalone {
        quote! { db }
    } else {
        quote! { &self.db }
    };

    // Find the request message to get filter/order_by field types
    let request_msg = file
        .message_type
        .iter()
        .find(|m| m.name.as_deref() == Some(request_type));

    // Generate filter code if request has a filter field
    let filter_code = request_msg
        .and_then(|msg| generate_filter_code(msg, entity_module, all_files))
        .unwrap_or_else(|| quote! {});

    // Generate orderBy code if request has an order_by field
    let has_order_by = request_msg
        .map(|msg| msg.field.iter().any(|f| f.name.as_deref() == Some("order_by")))
        .unwrap_or(false);

    let order_by_code = if has_order_by {
        request_msg
            .and_then(|msg| generate_order_by_code(msg, entity_module, all_files))
            .unwrap_or_else(|| quote! {})
    } else {
        quote! {}
    };

    let ordering_code = if has_order_by {
        quote! {
            // Apply ordering from request
            let mut ordered = false;
            #order_by_code
            if !ordered {
                // Default ordering by id if no order specified
                query = query.order_by_asc(entities::#entity_module::Column::Id);
            }
        }
    } else {
        quote! {
            // Default ordering by id
            query = query.order_by_asc(entities::#entity_module::Column::Id);
        }
    };

    quote! {
        use sea_orm::{QuerySelect, Condition};

        // Default limit
        let limit = request.first.or(request.last).unwrap_or(20) as u64;

        // Build base query
        let mut query = entities::#entity_module::Entity::find();

        // Apply filters
        #filter_code

        #ordering_code

        // Apply cursor filter (after = id to start after)
        if let Some(ref after) = request.after {
            if let Ok(cursor_id) = after.parse::<i64>() {
                query = query.filter(entities::#entity_module::Column::Id.gt(cursor_id));
            }
        }

        // Apply cursor filter (before = id to end before)
        if let Some(ref before) = request.before {
            if let Ok(cursor_id) = before.parse::<i64>() {
                query = query.filter(entities::#entity_module::Column::Id.lt(cursor_id));
            }
        }

        // Fetch one extra to determine if there's a next page
        let models = query
            .limit(limit + 1)
            .all(#db_ref)
            .await
            .map_err(StorageError::Database)?;

        let has_next_page = models.len() > limit as usize;
        let models: Vec<_> = models.into_iter().take(limit as usize).collect();

        let edges: Vec<#edge_ident> = models
            .into_iter()
            .map(|m| {
                let cursor = m.id.to_string();
                #edge_ident {
                    cursor,
                    node: Some(m.into()),
                }
            })
            .collect();

        let start_cursor = edges.first().map(|e| e.cursor.clone());
        let end_cursor = edges.last().map(|e| e.cursor.clone());

        Ok(#response_ident {
            edges,
            page_info: Some(PageInfo {
                has_next_page,
                has_previous_page: request.after.is_some(),
                start_cursor,
                end_cursor,
            }),
        })
    }
}

/// Generate filter condition code from request message
fn generate_filter_code(
    request_msg: &DescriptorProto,
    entity_module: &proc_macro2::Ident,
    all_files: &[FileDescriptorProto],
) -> Option<TokenStream> {
    // Find the filter field in the request
    let filter_field = request_msg.field.iter().find(|f| {
        f.name.as_deref() == Some("filter")
    })?;

    // Get the filter message type name
    let filter_type_name = filter_field.type_name.as_ref()?;
    let filter_type = filter_type_name.rsplit('.').next()?;

    // Find the filter message definition in any proto file
    let filter_msg = all_files
        .iter()
        .flat_map(|f| f.message_type.iter())
        .find(|m| m.name.as_deref() == Some(filter_type))?;

    // Generate condition code for each field in the filter
    let mut field_conditions = Vec::new();

    for field in &filter_msg.field {
        let field_name = field.name.as_deref()?;
        let field_ident = format_ident!("{}", field_name);
        let column_ident = format_ident!("{}", field_name.to_upper_camel_case());

        // Determine the filter type from the field's type_name
        let type_name = field.type_name.as_ref()?;
        let filter_kind = if type_name.contains("IntFilter") || type_name.contains("Int64Filter") || type_name.contains("Int32Filter") {
            FilterKind::Int
        } else if type_name.contains("StringFilter") {
            FilterKind::String
        } else if type_name.contains("BoolFilter") {
            FilterKind::Bool
        } else {
            continue; // Unknown filter type, skip
        };

        let condition_code = generate_field_filter_code(
            entity_module,
            &field_ident,
            &column_ident,
            filter_kind,
        );

        field_conditions.push(condition_code);
    }

    if field_conditions.is_empty() {
        return None;
    }

    Some(quote! {
        if let Some(ref filter) = request.filter {
            let mut cond = Condition::all();
            #(#field_conditions)*
            query = query.filter(cond);
        }
    })
}

/// Filter kind for code generation
enum FilterKind {
    Int,
    String,
    Bool,
}

/// Generate filter condition code for a single field
fn generate_field_filter_code(
    entity_module: &proc_macro2::Ident,
    field_ident: &proc_macro2::Ident,
    column_ident: &proc_macro2::Ident,
    filter_kind: FilterKind,
) -> TokenStream {
    match filter_kind {
        FilterKind::Int => {
            quote! {
                if let Some(ref f) = filter.#field_ident {
                    if let Some(v) = f.eq { cond = cond.add(entities::#entity_module::Column::#column_ident.eq(v)); }
                    if let Some(v) = f.neq { cond = cond.add(entities::#entity_module::Column::#column_ident.ne(v)); }
                    if let Some(v) = f.gt { cond = cond.add(entities::#entity_module::Column::#column_ident.gt(v)); }
                    if let Some(v) = f.gte { cond = cond.add(entities::#entity_module::Column::#column_ident.gte(v)); }
                    if let Some(v) = f.lt { cond = cond.add(entities::#entity_module::Column::#column_ident.lt(v)); }
                    if let Some(v) = f.lte { cond = cond.add(entities::#entity_module::Column::#column_ident.lte(v)); }
                    if !f.r#in.is_empty() { cond = cond.add(entities::#entity_module::Column::#column_ident.is_in(f.r#in.clone())); }
                }
            }
        }
        FilterKind::String => {
            quote! {
                if let Some(ref f) = filter.#field_ident {
                    if let Some(ref v) = f.eq { cond = cond.add(entities::#entity_module::Column::#column_ident.eq(v.clone())); }
                    if let Some(ref v) = f.neq { cond = cond.add(entities::#entity_module::Column::#column_ident.ne(v.clone())); }
                    if let Some(ref v) = f.contains { cond = cond.add(entities::#entity_module::Column::#column_ident.contains(v)); }
                    if let Some(ref v) = f.starts_with { cond = cond.add(entities::#entity_module::Column::#column_ident.starts_with(v)); }
                    if let Some(ref v) = f.ends_with { cond = cond.add(entities::#entity_module::Column::#column_ident.ends_with(v)); }
                }
            }
        }
        FilterKind::Bool => {
            quote! {
                if let Some(ref f) = filter.#field_ident {
                    if let Some(v) = f.eq { cond = cond.add(entities::#entity_module::Column::#column_ident.eq(v)); }
                }
            }
        }
    }
}

/// Generate orderBy code from request message
fn generate_order_by_code(
    request_msg: &DescriptorProto,
    entity_module: &proc_macro2::Ident,
    all_files: &[FileDescriptorProto],
) -> Option<TokenStream> {
    // Find the order_by field in the request
    let order_by_field = request_msg.field.iter().find(|f| {
        f.name.as_deref() == Some("order_by")
    })?;

    // Get the orderBy message type name
    let order_by_type_name = order_by_field.type_name.as_ref()?;
    let order_by_type = order_by_type_name.rsplit('.').next()?;

    // Find the orderBy message definition in any proto file
    let order_by_msg = all_files
        .iter()
        .flat_map(|f| f.message_type.iter())
        .find(|m| m.name.as_deref() == Some(order_by_type))?;

    // Generate ordering code for each field
    let mut order_statements = Vec::new();

    for field in &order_by_msg.field {
        let field_name = field.name.as_deref()?;
        let field_ident = format_ident!("{}", field_name);
        let column_ident = format_ident!("{}", field_name.to_upper_camel_case());

        order_statements.push(quote! {
            if let Some(d) = o.#field_ident {
                ordered = true;
                query = if d == 1 {
                    query.order_by_asc(entities::#entity_module::Column::#column_ident)
                } else {
                    query.order_by_desc(entities::#entity_module::Column::#column_ident)
                };
            }
        });
    }

    if order_statements.is_empty() {
        return None;
    }

    Some(quote! {
        if let Some(ref o) = request.order_by {
            #(#order_statements)*
        }
    })
}

/// Generate a CREATE implementation
///
/// If `for_standalone` is true, generates code using `db` parameter instead of `self.db`
pub fn generate_create_impl(
    entity_module: &proc_macro2::Ident,
    response_ident: &proc_macro2::Ident,
    _entity_options: Option<&storage::EntityOptions>,
    for_standalone: bool,
) -> TokenStream {
    let db_ref = if for_standalone {
        quote! { db }
    } else {
        quote! { &self.db }
    };

    quote! {
        // Request fields are directly on the request (no nested input)
        let active_model: entities::#entity_module::ActiveModel = request.into();
        let model = active_model.insert(#db_ref).await.map_err(StorageError::Database)?;

        Ok(#response_ident {
            #entity_module: Some(model.into()),
        })
    }
}

/// Generate an UPDATE implementation
///
/// If `for_standalone` is true, generates code using `db` parameter instead of `self.db`
pub fn generate_update_impl(
    entity_module: &proc_macro2::Ident,
    response_ident: &proc_macro2::Ident,
    _entity_options: Option<&storage::EntityOptions>,
    for_standalone: bool,
) -> TokenStream {
    // Derive the entity type name (e.g., user -> User)
    let entity_type = format_ident!("{}", entity_module.to_string().to_upper_camel_case());

    let db_ref = if for_standalone {
        quote! { db }
    } else {
        quote! { &self.db }
    };

    quote! {
        use sea_orm::IntoActiveModel;

        // Find existing entity
        let model = entities::#entity_module::Entity::find_by_id(request.id)
            .one(#db_ref)
            .await
            .map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(format!("{} with id {} not found", stringify!(#entity_type), request.id)))?;

        // Convert to active model and apply updates from request
        let mut active_model = model.into_active_model();
        active_model.apply_update(&request);

        let model = active_model.update(#db_ref).await.map_err(StorageError::Database)?;

        Ok(#response_ident {
            #entity_module: Some(model.into()),
        })
    }
}

/// Generate a DELETE implementation
///
/// If `for_standalone` is true, generates code using `db` parameter instead of `self.db`
pub fn generate_delete_impl(
    entity_module: &proc_macro2::Ident,
    response_ident: &proc_macro2::Ident,
    for_standalone: bool,
) -> TokenStream {
    let db_ref = if for_standalone {
        quote! { db }
    } else {
        quote! { &self.db }
    };

    quote! {
        let result = entities::#entity_module::Entity::delete_by_id(request.id)
            .exec(#db_ref)
            .await
            .map_err(StorageError::Database)?;

        Ok(#response_ident {
            success: result.rows_affected > 0,
        })
    }
}

