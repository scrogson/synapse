//! Storage implementation generation
//!
//! This module generates SeaORM-based implementations of storage traits.
//! The generated implementations bridge between gRPC request/response types
//! and SeaORM entities, handling CRUD operations.

use super::options::{
    get_cached_entity_options, get_cached_rpc_method_options, get_cached_service_options, storage,
};
use crate::error::GeneratorError;
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::TokenStream;
use prost_types::compiler::code_generator_response::File;
use prost_types::{FileDescriptorProto, MethodDescriptorProto, ServiceDescriptorProto};
use quote::{format_ident, quote};

/// Generate a SeaORM-based storage implementation from a protobuf service
pub fn generate(
    file: &FileDescriptorProto,
    service: &ServiceDescriptorProto,
) -> Result<Option<File>, GeneratorError> {
    let file_name = file.name.as_deref().unwrap_or("");
    let service_name = service.name.as_deref().unwrap_or("");

    // Check if this service has storage options with generate_implementation
    let service_options = match get_cached_service_options(file_name, service_name) {
        Some(opts) => opts,
        None => return Ok(None),
    };

    // Skip if explicitly marked or if generate_storage is false
    if service_options.skip || !service_options.generate_storage {
        return Ok(None);
    }

    // Skip if generate_implementation is false
    if !service_options.generate_implementation {
        return Ok(None);
    }

    // Determine trait name
    let trait_name = if service_options.trait_name.is_empty() {
        format!("{}Storage", service_name)
    } else {
        service_options.trait_name.clone()
    };

    // Generate the output filename
    let impl_name = format!("SeaOrm{}", trait_name);
    let module_name = impl_name.to_snake_case();
    let output_filename = format!(
        "{}/{}.rs",
        file.package.as_deref().unwrap_or("").replace('.', "/"),
        module_name
    );

    // Generate method implementations
    let methods = generate_impl_methods(file, service)?;

    // Build identifiers
    let impl_ident = format_ident!("{}", impl_name);
    let trait_ident = format_ident!("{}", trait_name);

    // Build doc comment
    let module_doc = format!("SeaORM-based storage implementation for {}", service_name);
    let struct_doc = format!(
        "SeaORM-based implementation of {} using DatabaseConnection",
        trait_name
    );

    // Import the storage trait module to get StorageError
    let trait_module = format_ident!("{}", trait_name.to_snake_case());

    let code = quote! {
        #![doc = #module_doc]
        //!
        //! Generated by protoc-gen-synapse from protobuf service definition.
        //! @generated

        #![allow(missing_docs)]
        #![allow(unused_imports)]

        use super::prelude::*;
        use super::#trait_module::{#trait_ident, StorageError};
        use super::conversions::ApplyUpdate;
        use sea_orm::{
            ActiveModelTrait, ColumnTrait, DatabaseConnection, EntityTrait,
            QueryFilter, QueryOrder, Set,
        };

        #[doc = #struct_doc]
        #[derive(Clone)]
        pub struct #impl_ident {
            db: DatabaseConnection,
        }

        impl #impl_ident {
            /// Create a new storage implementation with the given database connection
            pub fn new(db: DatabaseConnection) -> Self {
                Self { db }
            }

            /// Get a reference to the database connection
            pub fn db(&self) -> &DatabaseConnection {
                &self.db
            }
        }

        #[async_trait::async_trait]
        impl #trait_ident for #impl_ident {
            #(#methods)*
        }
    };

    // Format the generated code
    let content = code.to_string();

    // Try to format with prettyplease if we can parse it
    let formatted = match syn::parse_file(&content) {
        Ok(parsed) => prettyplease::unparse(&parsed),
        Err(_) => content, // If parsing fails, use unformatted
    };

    Ok(Some(File {
        name: Some(output_filename),
        content: Some(formatted),
        ..Default::default()
    }))
}

/// Generate storage method implementations
fn generate_impl_methods(
    file: &FileDescriptorProto,
    service: &ServiceDescriptorProto,
) -> Result<Vec<TokenStream>, GeneratorError> {
    let file_name = file.name.as_deref().unwrap_or("");
    let service_name = service.name.as_deref().unwrap_or("");
    let mut result = Vec::new();

    for method in &service.method {
        let method_name = method.name.as_deref().unwrap_or("");

        // Check for method-level options
        let method_options = get_cached_rpc_method_options(file_name, service_name, method_name);

        // Skip if marked
        if method_options.as_ref().map(|o| o.skip).unwrap_or(false) {
            continue;
        }

        // Determine Rust method name
        let rust_method_name = method_options
            .as_ref()
            .filter(|o| !o.method_name.is_empty())
            .map(|o| o.method_name.clone())
            .unwrap_or_else(|| method_name.to_snake_case());

        // Extract entity name from method options or infer from method name
        let entity_name = method_options
            .as_ref()
            .filter(|o| !o.entity_name.is_empty())
            .map(|o| o.entity_name.clone())
            .unwrap_or_else(|| infer_entity_name(method_name));

        // Generate the method implementation based on method pattern
        let method_impl =
            generate_method_impl(file, method, &rust_method_name, &entity_name, &method_options)?;

        if let Some(impl_tokens) = method_impl {
            result.push(impl_tokens);
        }
    }

    Ok(result)
}

/// Generate a method implementation based on the RPC pattern
fn generate_method_impl(
    file: &FileDescriptorProto,
    method: &MethodDescriptorProto,
    rust_method_name: &str,
    entity_name: &str,
    method_options: &Option<storage::MethodOptions>,
) -> Result<Option<TokenStream>, GeneratorError> {
    let file_name = file.name.as_deref().unwrap_or("");
    let method_name = method.name.as_deref().unwrap_or("");

    // Get the operation type from method options or infer from method name
    let operation = method_options
        .as_ref()
        .filter(|o| !o.operation.is_empty())
        .map(|o| o.operation.as_str())
        .unwrap_or_else(|| infer_operation(method_name));

    // Extract input/output types
    let request_type = extract_type_name(method.input_type.as_deref());
    let response_type = extract_type_name(method.output_type.as_deref());

    let method_ident = format_ident!("{}", rust_method_name);
    let request_ident = format_ident!("{}", request_type);
    let response_ident = format_ident!("{}", response_type);
    let entity_module = format_ident!("{}", entity_name.to_snake_case());

    // Check if we have entity options for this entity (to get relations, etc.)
    let entity_options = get_cached_entity_options(file_name, &entity_name.to_upper_camel_case());

    let method_body = match operation {
        "get" | "Get" | "GET" => {
            generate_get_impl(&entity_module, &response_ident, entity_options.as_ref())
        }
        "list" | "List" | "LIST" => {
            generate_list_impl(&entity_module, &response_ident, entity_options.as_ref())
        }
        "create" | "Create" | "CREATE" => {
            generate_create_impl(&entity_module, &response_ident, entity_options.as_ref())
        }
        "update" | "Update" | "UPDATE" => {
            generate_update_impl(&entity_module, &response_ident, entity_options.as_ref())
        }
        "delete" | "Delete" | "DELETE" => generate_delete_impl(&entity_module, &response_ident),
        _ => {
            // Unknown operation, generate a placeholder
            quote! {
                todo!("Implement {} for {}", stringify!(#method_ident), stringify!(#entity_module))
            }
        }
    };

    let method_token = quote! {
        async fn #method_ident(
            &self,
            request: #request_ident,
        ) -> Result<#response_ident, StorageError> {
            #method_body
        }
    };

    Ok(Some(method_token))
}

/// Generate a GET implementation
fn generate_get_impl(
    entity_module: &proc_macro2::Ident,
    response_ident: &proc_macro2::Ident,
    _entity_options: Option<&storage::EntityOptions>,
) -> TokenStream {
    // Derive the entity type name (e.g., user -> User)
    let entity_type = format_ident!("{}", entity_module.to_string().to_upper_camel_case());

    quote! {
        let model = #entity_module::Entity::find_by_id(request.id)
            .one(&self.db)
            .await
            .map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(format!("{} with id {} not found", stringify!(#entity_type), request.id)))?;

        Ok(#response_ident {
            #entity_module: Some(model.into()),
        })
    }
}

/// Generate a LIST implementation
fn generate_list_impl(
    entity_module: &proc_macro2::Ident,
    response_ident: &proc_macro2::Ident,
    _entity_options: Option<&storage::EntityOptions>,
) -> TokenStream {
    // Derive the edge type name (e.g., user -> UserEdge)
    let entity_type = entity_module.to_string().to_upper_camel_case();
    let edge_ident = format_ident!("{}Edge", entity_type);

    quote! {
        use sea_orm::QuerySelect;

        // Default limit
        let limit = request.first.or(request.last).unwrap_or(20) as u64;

        // Build query with cursor-based pagination
        let mut query = #entity_module::Entity::find()
            .order_by_asc(#entity_module::Column::Id);

        // Apply cursor filter (after = id to start after)
        if let Some(ref after) = request.after {
            if let Ok(cursor_id) = after.parse::<i64>() {
                query = query.filter(#entity_module::Column::Id.gt(cursor_id));
            }
        }

        // Apply cursor filter (before = id to end before)
        if let Some(ref before) = request.before {
            if let Ok(cursor_id) = before.parse::<i64>() {
                query = query.filter(#entity_module::Column::Id.lt(cursor_id));
            }
        }

        // Fetch one extra to determine if there's a next page
        let models = query
            .limit(limit + 1)
            .all(&self.db)
            .await
            .map_err(StorageError::Database)?;

        let has_next_page = models.len() > limit as usize;
        let models: Vec<_> = models.into_iter().take(limit as usize).collect();

        let edges: Vec<#edge_ident> = models
            .into_iter()
            .map(|m| {
                let cursor = m.id.to_string();
                #edge_ident {
                    cursor,
                    node: Some(m.into()),
                }
            })
            .collect();

        let start_cursor = edges.first().map(|e| e.cursor.clone());
        let end_cursor = edges.last().map(|e| e.cursor.clone());

        Ok(#response_ident {
            edges,
            page_info: Some(PageInfo {
                has_next_page,
                has_previous_page: request.after.is_some(),
                start_cursor,
                end_cursor,
            }),
        })
    }
}

/// Generate a CREATE implementation
fn generate_create_impl(
    entity_module: &proc_macro2::Ident,
    response_ident: &proc_macro2::Ident,
    _entity_options: Option<&storage::EntityOptions>,
) -> TokenStream {
    quote! {
        let input = request.input.ok_or_else(|| {
            StorageError::InvalidArgument("input is required".to_string())
        })?;

        let active_model: #entity_module::ActiveModel = input.into();
        let model = active_model.insert(&self.db).await.map_err(StorageError::Database)?;

        Ok(#response_ident {
            #entity_module: Some(model.into()),
        })
    }
}

/// Generate an UPDATE implementation
fn generate_update_impl(
    entity_module: &proc_macro2::Ident,
    response_ident: &proc_macro2::Ident,
    _entity_options: Option<&storage::EntityOptions>,
) -> TokenStream {
    // Derive the entity type name (e.g., user -> User)
    let entity_type = format_ident!("{}", entity_module.to_string().to_upper_camel_case());

    quote! {
        use sea_orm::IntoActiveModel;

        let input = request.input.ok_or_else(|| {
            StorageError::InvalidArgument("input is required".to_string())
        })?;

        // Find existing entity
        let model = #entity_module::Entity::find_by_id(request.id)
            .one(&self.db)
            .await
            .map_err(StorageError::Database)?
            .ok_or_else(|| StorageError::NotFound(format!("{} with id {} not found", stringify!(#entity_type), request.id)))?;

        // Convert to active model and apply updates
        let mut active_model = model.into_active_model();
        active_model.apply_update(input);

        let model = active_model.update(&self.db).await.map_err(StorageError::Database)?;

        Ok(#response_ident {
            #entity_module: Some(model.into()),
        })
    }
}

/// Generate a DELETE implementation
fn generate_delete_impl(
    entity_module: &proc_macro2::Ident,
    response_ident: &proc_macro2::Ident,
) -> TokenStream {
    quote! {
        let result = #entity_module::Entity::delete_by_id(request.id)
            .exec(&self.db)
            .await
            .map_err(StorageError::Database)?;

        Ok(#response_ident {
            success: result.rows_affected > 0,
        })
    }
}

/// Infer entity name from method name
///
/// Examples:
/// - GetUser -> User
/// - ListUsers -> User
/// - CreatePost -> Post
fn infer_entity_name(method_name: &str) -> String {
    let name = method_name
        .strip_prefix("Get")
        .or_else(|| method_name.strip_prefix("List"))
        .or_else(|| method_name.strip_prefix("Create"))
        .or_else(|| method_name.strip_prefix("Update"))
        .or_else(|| method_name.strip_prefix("Delete"))
        .unwrap_or(method_name);

    // Remove trailing 's' for List methods (ListUsers -> User)
    if method_name.starts_with("List") && name.ends_with('s') {
        name.strip_suffix('s').unwrap_or(name).to_string()
    } else {
        name.to_string()
    }
}

/// Infer operation type from method name
fn infer_operation(method_name: &str) -> &'static str {
    if method_name.starts_with("Get") {
        "get"
    } else if method_name.starts_with("List") {
        "list"
    } else if method_name.starts_with("Create") {
        "create"
    } else if method_name.starts_with("Update") {
        "update"
    } else if method_name.starts_with("Delete") {
        "delete"
    } else {
        "unknown"
    }
}

/// Extract a Rust type name from a protobuf type path
fn extract_type_name(type_name: Option<&str>) -> String {
    match type_name {
        Some(name) => {
            let type_part = name
                .rsplit('.')
                .next()
                .unwrap_or(name)
                .trim_start_matches('.');

            type_part.to_upper_camel_case()
        }
        None => "()".to_string(),
    }
}
