//! SeaORM backend for Rust code generation
//!
//! Generates SeaORM 2.0 entities with dense format.

use super::{Backend, BackendError};
use crate::ir::{Entity, Enum, Field, FieldType, RelationType};
use prost_types::compiler::code_generator_response::File;

/// SeaORM backend for Rust
pub struct SeaOrmBackend;

impl Backend for SeaOrmBackend {
    fn name(&self) -> &str {
        "seaorm"
    }

    fn file_extension(&self) -> &str {
        "rs"
    }

    fn generate_entity(&self, entity: &Entity) -> Result<File, BackendError> {
        // TODO: Implement entity generation
        // This will be migrated from protoc-gen-seaorm
        let content = format!(
            r#"//! SeaORM entity for {}
//!
//! Generated by protoc-gen-synapse.
//! @generated

use sea_orm::entity::prelude::*;

// TODO: Generate entity struct for {}
"#,
            entity.name, entity.name
        );

        Ok(File {
            name: Some(format!("{}.rs", entity.table_name)),
            content: Some(content),
            ..Default::default()
        })
    }

    fn generate_enum(&self, enum_def: &Enum) -> Result<File, BackendError> {
        // TODO: Implement enum generation
        let content = format!(
            r#"//! SeaORM enum for {}
//!
//! Generated by protoc-gen-synapse.
//! @generated

use sea_orm::entity::prelude::*;

// TODO: Generate enum for {}
"#,
            enum_def.name, enum_def.name
        );

        Ok(File {
            name: Some(format!("{}.rs", heck::AsSnakeCase(&enum_def.name))),
            content: Some(content),
            ..Default::default()
        })
    }

    fn generate_prelude(&self, package: &str) -> Result<Option<File>, BackendError> {
        let content = r#"//! Prelude for generated entities
//!
//! Generated by protoc-gen-synapse.
//! @generated

pub use sea_orm::entity::prelude::*;
pub use sea_orm::{Related, RelationDef, RelationTrait};
"#;

        Ok(Some(File {
            name: Some(format!("{}/prelude.rs", package.replace('.', "/"))),
            content: Some(content.to_string()),
            ..Default::default()
        }))
    }
}

/// Map IR field type to Rust type
fn map_type(field_type: &FieldType, nullable: bool) -> String {
    let base = match field_type {
        FieldType::Bool => "bool",
        FieldType::Int32 => "i32",
        FieldType::Int64 => "i64",
        FieldType::Uint32 => "u32",
        FieldType::Uint64 => "u64",
        FieldType::Float => "f32",
        FieldType::Double => "f64",
        FieldType::String => "String",
        FieldType::Bytes => "Vec<u8>",
        FieldType::Timestamp => "DateTimeUtc",
        FieldType::Message(name) => name,
        FieldType::Enum(name) => name,
    };

    if nullable {
        format!("Option<{}>", base)
    } else {
        base.to_string()
    }
}

/// Generate SeaORM column attribute
fn generate_column_attr(field: &Field) -> Vec<String> {
    let mut attrs = Vec::new();

    if field.primary_key {
        if field.auto_increment {
            attrs.push("primary_key".to_string());
        } else {
            attrs.push("primary_key, auto_increment = false".to_string());
        }
    }

    if field.unique {
        attrs.push("unique".to_string());
    }

    if let Some(ref name) = field.column_name {
        attrs.push(format!("column_name = \"{}\"", name));
    }

    attrs
}
