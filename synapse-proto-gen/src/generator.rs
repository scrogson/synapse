//! Proto file generation
//!
//! Generates proto definitions for filter, connection, and CRUD types.

use crate::parser::EntityInfo;
use heck::ToSnakeCase;

/// Generate the complete proto file content
pub fn generate_proto(
    entities: &[EntityInfo],
    source_files: &[String],
) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    // Get package from first entity
    let package = entities
        .first()
        .map(|e| e.package.as_str())
        .unwrap_or("generated");

    // Header
    output.push_str(
        r#"// Auto-generated by synapse-proto-gen
// DO NOT EDIT - changes will be overwritten

syntax = "proto3";

"#,
    );

    output.push_str(&format!("package {package};\n\n"));

    // Import synapse relay types (filters, PageInfo, OrderDirection)
    output.push_str("import \"synapse/relay/types.proto\";\n");

    // Import source files (for entity type references in Edge types)
    for source in source_files {
        output.push_str(&format!("import \"{source}\";\n"));
    }

    output.push('\n');

    // Generate entity-specific types (filters, connections - NOT request/response)
    for entity in entities {
        output.push_str(&format!("\n// {} types\n", entity.name));
        output.push_str(&generate_entity_filter(entity));
        output.push_str(&generate_entity_order_by(entity));
        output.push_str(&generate_entity_edge(entity));
        output.push_str(&generate_entity_connection(entity));
        // Note: Request/Response messages are user-defined, not generated
    }

    Ok(output)
}

/// Generate entity-specific filter type
fn generate_entity_filter(entity: &EntityInfo) -> String {
    let mut output = format!("message {}Filter {{\n", entity.name);

    let mut field_num = 1;

    // Always include id filter first
    output.push_str(&format!(
        "  optional synapse.relay.IntFilter id = {};\n",
        field_num
    ));
    field_num += 1;

    for field in &entity.fields {
        // Skip id (already added) and timestamps (add at end)
        if field.name == "id" || field.name == "created_at" || field.name == "updated_at" {
            continue;
        }

        if let Some(filter_type) = field.proto_type.filter_type() {
            output.push_str(&format!(
                "  optional synapse.relay.{} {} = {};\n",
                filter_type,
                field.name.to_snake_case(),
                field_num
            ));
            field_num += 1;
        }
    }

    // Add timestamp filters at the end
    output.push_str(&format!(
        "  optional synapse.relay.TimestampFilter created_at = {};\n",
        field_num
    ));
    field_num += 1;
    output.push_str(&format!(
        "  optional synapse.relay.TimestampFilter updated_at = {};\n",
        field_num
    ));
    field_num += 1;

    // Add logical operators for filter composition
    output.push_str(&format!(
        "  // Logical operators\n  repeated {name}Filter and = {and_num};\n  repeated {name}Filter or = {or_num};\n  optional {name}Filter not = {not_num};\n",
        name = entity.name,
        and_num = field_num,
        or_num = field_num + 1,
        not_num = field_num + 2
    ));

    output.push_str("}\n\n");
    output
}

/// Generate entity-specific order by type
fn generate_entity_order_by(entity: &EntityInfo) -> String {
    let mut output = format!("message {}OrderBy {{\n", entity.name);

    let mut field_num = 1;

    // Always include id ordering first
    output.push_str(&format!(
        "  optional synapse.relay.OrderDirection id = {};\n",
        field_num
    ));
    field_num += 1;

    for field in &entity.fields {
        // Skip id (already added) and timestamps (add at end)
        if field.name == "id" || field.name == "created_at" || field.name == "updated_at" {
            continue;
        }

        if field.proto_type.supports_ordering() {
            output.push_str(&format!(
                "  optional synapse.relay.OrderDirection {} = {};\n",
                field.name.to_snake_case(),
                field_num
            ));
            field_num += 1;
        }
    }

    // Add timestamp ordering at the end
    output.push_str(&format!(
        "  optional synapse.relay.OrderDirection created_at = {};\n",
        field_num
    ));
    field_num += 1;
    output.push_str(&format!(
        "  optional synapse.relay.OrderDirection updated_at = {};\n",
        field_num
    ));

    output.push_str("}\n\n");
    output
}

/// Generate entity edge type
fn generate_entity_edge(entity: &EntityInfo) -> String {
    format!(
        r#"message {name}Edge {{
  string cursor = 1;
  {name} node = 2;
}}

"#,
        name = entity.name
    )
}

/// Generate entity connection type
fn generate_entity_connection(entity: &EntityInfo) -> String {
    format!(
        r#"message {name}Connection {{
  repeated {name}Edge edges = 1;
  synapse.relay.PageInfo page_info = 2;
}}

"#,
        name = entity.name
    )
}

