//! Proto file generation
//!
//! Generates proto definitions for filter, connection, and CRUD types.

use crate::parser::{EntityInfo, ProtoType};
use heck::ToSnakeCase;

/// Generate the complete proto file content
pub fn generate_proto(entities: &[EntityInfo]) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    // Get package from first entity
    let package = entities
        .first()
        .map(|e| e.package.as_str())
        .unwrap_or("generated");

    // Header
    output.push_str(&format!(
        r#"// Auto-generated by synapse-proto-gen
// DO NOT EDIT - changes will be overwritten

syntax = "proto3";

package {package};

import "google/protobuf/timestamp.proto";

"#
    ));

    // Generate primitive filter types
    output.push_str(&generate_primitive_types());

    // Generate entity-specific types
    for entity in entities {
        output.push_str(&format!("\n// {} types\n", entity.name));
        output.push_str(&generate_entity_filter(entity));
        output.push_str(&generate_entity_order_by(entity));
        output.push_str(&generate_entity_edge(entity));
        output.push_str(&generate_entity_connection(entity));
        output.push_str(&generate_crud_messages(entity));
    }

    Ok(output)
}

/// Generate primitive filter types
fn generate_primitive_types() -> String {
    r#"// =============================================================================
// Primitive Filter Types
// =============================================================================

message StringFilter {
  optional string eq = 1;
  optional string ne = 2;
  optional string contains = 3;
  optional string starts_with = 4;
  optional string ends_with = 5;
}

message IntFilter {
  optional int64 eq = 1;
  optional int64 ne = 2;
  optional int64 gt = 3;
  optional int64 gte = 4;
  optional int64 lt = 5;
  optional int64 lte = 6;
  repeated int64 in = 7;
}

message FloatFilter {
  optional double eq = 1;
  optional double ne = 2;
  optional double gt = 3;
  optional double gte = 4;
  optional double lt = 5;
  optional double lte = 6;
}

message BoolFilter {
  optional bool eq = 1;
}

message TimestampFilter {
  optional google.protobuf.Timestamp eq = 1;
  optional google.protobuf.Timestamp ne = 2;
  optional google.protobuf.Timestamp gt = 3;
  optional google.protobuf.Timestamp gte = 4;
  optional google.protobuf.Timestamp lt = 5;
  optional google.protobuf.Timestamp lte = 6;
}

enum OrderDirection {
  ORDER_DIRECTION_UNSPECIFIED = 0;
  ASC = 1;
  DESC = 2;
}

message PageInfo {
  bool has_next_page = 1;
  bool has_previous_page = 2;
  optional string start_cursor = 3;
  optional string end_cursor = 4;
}

"#
    .to_string()
}

/// Generate entity-specific filter type
fn generate_entity_filter(entity: &EntityInfo) -> String {
    let mut output = format!("message {}Filter {{\n", entity.name);

    let mut field_num = 1;

    // Always include id filter first
    output.push_str(&format!("  optional IntFilter id = {};\n", field_num));
    field_num += 1;

    for field in &entity.fields {
        // Skip id (already added) and timestamps (add at end)
        if field.name == "id" || field.name == "created_at" || field.name == "updated_at" {
            continue;
        }

        if let Some(filter_type) = field.proto_type.filter_type() {
            output.push_str(&format!(
                "  optional {} {} = {};\n",
                filter_type,
                field.name.to_snake_case(),
                field_num
            ));
            field_num += 1;
        }
    }

    // Add timestamp filters at the end
    output.push_str(&format!(
        "  optional TimestampFilter created_at = {};\n",
        field_num
    ));
    field_num += 1;
    output.push_str(&format!(
        "  optional TimestampFilter updated_at = {};\n",
        field_num
    ));

    output.push_str("}\n\n");
    output
}

/// Generate entity-specific order by type
fn generate_entity_order_by(entity: &EntityInfo) -> String {
    let mut output = format!("message {}OrderBy {{\n", entity.name);

    let mut field_num = 1;

    // Always include id ordering first
    output.push_str(&format!(
        "  optional OrderDirection id = {};\n",
        field_num
    ));
    field_num += 1;

    for field in &entity.fields {
        // Skip id (already added) and timestamps (add at end)
        if field.name == "id" || field.name == "created_at" || field.name == "updated_at" {
            continue;
        }

        if field.proto_type.supports_ordering() {
            output.push_str(&format!(
                "  optional OrderDirection {} = {};\n",
                field.name.to_snake_case(),
                field_num
            ));
            field_num += 1;
        }
    }

    // Add timestamp ordering at the end
    output.push_str(&format!(
        "  optional OrderDirection created_at = {};\n",
        field_num
    ));
    field_num += 1;
    output.push_str(&format!(
        "  optional OrderDirection updated_at = {};\n",
        field_num
    ));

    output.push_str("}\n\n");
    output
}

/// Generate entity edge type
fn generate_entity_edge(entity: &EntityInfo) -> String {
    format!(
        r#"message {name}Edge {{
  string cursor = 1;
  {name} node = 2;
}}

"#,
        name = entity.name
    )
}

/// Generate entity connection type
fn generate_entity_connection(entity: &EntityInfo) -> String {
    format!(
        r#"message {name}Connection {{
  repeated {name}Edge edges = 1;
  PageInfo page_info = 2;
}}

"#,
        name = entity.name
    )
}

/// Generate CRUD request/response messages for an entity
fn generate_crud_messages(entity: &EntityInfo) -> String {
    let name = &entity.name;
    let name_lower = name.to_snake_case();

    // Find primary key field
    let pk_field = entity
        .fields
        .iter()
        .find(|f| f.primary_key)
        .or_else(|| entity.fields.iter().find(|f| f.name == "id"));

    let pk_type = pk_field
        .map(|f| proto_type_to_string(&f.proto_type))
        .unwrap_or("int64");

    let pk_name = pk_field.map(|f| f.name.as_str()).unwrap_or("id");

    let mut output = String::new();

    // GetRequest/Response
    output.push_str(&format!(
        r#"message Get{name}Request {{
  {pk_type} {pk_name} = 1;
}}

message Get{name}Response {{
  {name} {name_lower} = 1;
}}

"#
    ));

    // ListRequest (returns Connection)
    output.push_str(&format!(
        r#"message List{name}sRequest {{
  // Relay pagination
  optional string after = 1;
  optional string before = 2;
  optional int32 first = 3;
  optional int32 last = 4;
  // Filter & ordering
  optional {name}Filter filter = 5;
  optional {name}OrderBy order_by = 6;
}}

"#
    ));

    // CreateRequest/Response
    output.push_str(&format!("message Create{name}Request {{\n"));
    let mut field_num = 1;
    for field in &entity.fields {
        // Skip primary key and auto-generated fields
        if field.primary_key
            || field.name == "id"
            || field.name == "created_at"
            || field.name == "updated_at"
        {
            continue;
        }

        let type_str = proto_type_to_string(&field.proto_type);
        let optional = if field.optional { "optional " } else { "" };
        output.push_str(&format!(
            "  {}{} {} = {};\n",
            optional,
            type_str,
            field.name.to_snake_case(),
            field_num
        ));
        field_num += 1;
    }
    output.push_str("}\n\n");

    output.push_str(&format!(
        r#"message Create{name}Response {{
  {name} {name_lower} = 1;
}}

"#
    ));

    // UpdateRequest/Response
    output.push_str(&format!("message Update{name}Request {{\n"));
    output.push_str(&format!("  {pk_type} {pk_name} = 1;\n"));
    let mut field_num = 2;
    for field in &entity.fields {
        // Skip primary key and auto-generated fields
        if field.primary_key
            || field.name == "id"
            || field.name == "created_at"
            || field.name == "updated_at"
        {
            continue;
        }

        let type_str = proto_type_to_string(&field.proto_type);
        // All fields in update are optional
        output.push_str(&format!(
            "  optional {} {} = {};\n",
            type_str,
            field.name.to_snake_case(),
            field_num
        ));
        field_num += 1;
    }
    output.push_str("}\n\n");

    output.push_str(&format!(
        r#"message Update{name}Response {{
  {name} {name_lower} = 1;
}}

"#
    ));

    // DeleteRequest/Response
    output.push_str(&format!(
        r#"message Delete{name}Request {{
  {pk_type} {pk_name} = 1;
}}

message Delete{name}Response {{
  bool success = 1;
}}

"#
    ));

    output
}

/// Convert proto type to string representation
fn proto_type_to_string(proto_type: &ProtoType) -> &'static str {
    match proto_type {
        ProtoType::Int32 => "int32",
        ProtoType::Int64 => "int64",
        ProtoType::Uint32 => "uint32",
        ProtoType::Uint64 => "uint64",
        ProtoType::Float => "float",
        ProtoType::Double => "double",
        ProtoType::Bool => "bool",
        ProtoType::String => "string",
        ProtoType::Bytes => "bytes",
        ProtoType::Timestamp => "google.protobuf.Timestamp",
        ProtoType::Message => "bytes", // fallback
        ProtoType::Enum => "int32",    // fallback
    }
}
